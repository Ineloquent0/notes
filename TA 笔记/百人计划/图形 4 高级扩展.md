# 1. Bloom 算法

## 1.1 Bloom 算法介绍

### 1.1.1 Bloom 效果

![Bloom 效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241211195300.jpg)
![Bloom 效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241211195515.jpg)

### 什么是Bloom
* Bloom，也称辉光效果
* 模拟摄像机的一种图像效果
* 让物体具有真实的明亮效果

![Bloom 效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/cd72c59a-e430-4bee-b1fe-01b1c3e2d12f.jpg)

我们来看一下这张使用单反拍摄的照片，路灯和远处建筑外墙灯饰的灯光效果和Bloom效果是一致的，也就是说，Bloom效果可以用来模拟真实世界中，摄像机的一种图像效果，**它可以让画面中比较亮的区域扩散到周围的区域中，来达到一种朦胧的效果，并且能让我们的眼睛感知到这些区域是比较亮的**


### 1.1.2 实现思路

1. 先利用原图像，**通过一个预先设定的阈值去提取原图像中比较亮的区域**，比如左下角这张图，它是提取后的
2. 然后**利用高斯模糊对提取后的图像进行模糊处理**，这么做是为了模拟光线往外扩散的效果
3. 最后**将模糊后的图像与原图像进行一个混合**，得到最终的Bloom效果，比如右上角这张图所示

![Bloom 实现思路](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241211202449.jpg)

![Bloom](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240923115247.jpg)


### 1.1.3 前置知识

#### HDR与LDR

**LDR(Low Dynamic Range，低动态范围)**
- JPG、PNG格式图片
- RGB范围在[0, 1]之间

> 简单理解的话，JPG、PNG等格式的图片，以及日常生活中使用的手机、显示器、摄像机这些设备的输入与输出均为LDR，因为LDR只能存储RGB范围在0到1之间的值
但在现实世界中，只用0到1范围内的值去表达真实世界中的色彩是远远不够的，意味着会存在精度的丢失，而高动态范围的出现，则解决了这个问题

**HDR(High Dynamic Range，高动态范围)**
- HDR、EXR格式图片
- RGB范围可在[0, 1]之外

> * HDR允许我们表示超过0到1之间的亮度值，进而可以更加精确地反映真实的光照效果
> * Bloom效果的第一步，就是利用阈值去提取原图像中比较亮的区域，如果不使用HDR的话，我们就只能提取亮度小于1的区域，并且像路灯发亮的亮度值可能会与某个区域的亮度值一致，这样就会导致这个区域也出现Bloom效果；
> * 但如果使用HDR的话，则可以提取亮度大于1的区域，这样就能让更亮的区域产生Bloom效果，所以，**提取较亮区域有时候是针对开启HDR来实现的**

可参考2.6节：https://github.com/Ineloquent0/notes/blob/main/TA%20%E7%AC%94%E8%AE%B0/%E7%99%BE%E4%BA%BA%E8%AE%A1%E5%88%92/%E5%9B%BE%E5%BD%A2%202%20%E5%85%89%E7%85%A7%E5%9F%BA%E7%A1%80-2.md#6-ldr-%E4%B8%8E-hdr


#### 高斯模糊
它是实现图像模糊的一种方式，它的本质是**通过高斯函数去定义一个卷积核**，这个卷积核叫做高斯核，**再利用这个高斯核对图像进行卷积运算**，得到“平滑”后的图像，也就是俗称的模糊

![高斯模糊](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241211211653.jpg)


##### 卷积
卷积是一种操作，我们会**利用一个卷积核对图像中的每个像素进行操作**，这个卷积核通常是由正方形组成的区域，区域大小可以是2×2、3×3的，也可以是5×5、7×7的，在这个正方形内的每一个格子都会有一个权重值

![卷积核](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241211212156.jpg)

我们将卷积核的中心放置在图像的起始像素上，翻转卷积核后依次计算核中每个元素和对应被核覆盖的像素值的乘积后，再求和，最终结果就是这个位置得到一个新的像素值，之后滑动卷积核，继续重复这个步骤直到全部像素的值被重新计算，下面这张动图可以很清晰地表示卷积的过程

![卷积过程](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/7e97f6fc-4b5b-47af-9692-7c4fd0b2e1e5.gif)


##### 计算高斯核

高斯核：高斯模糊使用的卷积核叫做高斯核
- 核中心：(0, 0)
- 核大小：3x3
- 标准方差σ ：1.5

![高斯核](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241211213334.png)

我们可以利用高斯函数求出这个核内的权重值
* 假设核的中心为(0, 0)，这个高斯核的大小为3×3，那么将所有点放入这九个格子中就可以得到这样的结果，其中，(-1, 1)分别对应了x、y的值为-1和1
* 然后确定标准方差σ的值，这里假设它为1.5，以核中心(0, 0)为例，将(0, 0)代入高斯函数计算得到这个格子的权重约为0.0707。
可以发现，高斯核内的每个权重体现了对当前处理像素的影响程度，距离中心越近的，它的则权重就越大，影响也就越大
* 为了保证卷积后的图像不变暗，需要对高斯核的权重进行归一化处理，也就是让每个权重除以所有权重的和，现在的这个高斯核就是最终的结果

**二维高斯核特点：**
- 计算量大，N\*N\*W\*H次纹理采样
- 可分离性，可拆成两个一维高斯核

随着高斯核维数的增加，模糊的程度也会变大。
* 假设图像的宽度和高度分别为W和H，如果使用一个大小为N\*N的高斯核对图像进行卷积计算的话，那么就需要N\*N\*W\*H次纹理采样，计算量会变得非常大。
* 二维高斯函数具有可分离性，我们可以将它拆成两个一维函数，也就是说，可以使用两个一维的高斯核先后对图像进行卷积，卷积结果与使用二维高斯核进行卷积是一样的，但计算量变为2\*N\*W\*H
* 同时，一维高斯核中包含了很多重复的权重，换句话说，**它具有对称性，对于一个大小为5的一维高斯核，实际上只要记录三个权重值就可以了**

![二维高斯核](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/f47f638e-8b84-44a4-a2bc-d632ba3232ae.png)


## 1.2 Bloom 算法实现

详情参考：[Shader 入门精要 12.5节 Bloom效果](https://github.com/Ineloquent0/notes/blob/main/TA%20%E7%AC%94%E8%AE%B0/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/04%20%E9%AB%98%E7%BA%A7%E7%AF%87.md#125-bloom-%E6%95%88%E6%9E%9C)




