# 1. 常用 DCC 工具
所谓 DCC，就是 Digital Content Creation 的缩写，即 数字内容创作。DCC 的范围包括二维 / 三维、音频 / 视频编辑合成、动态 / 互动内容创作、图像编辑等。

## 1.1 常用建模软件

没有最好的建模软件，每个软件有各自的优势，按自己的需求、公司的需求、行业的需求进行学习即可，学习任何的软件都是有价值的，并没有高低贵贱之分，软件之间的转换其实也是很快的（思路共通）

* 3DS MAX：硬表面建模、静态物体建模、国内使用最广泛
* MAYA：有非常强大的动画功能，可定制性也很强，可以用软件本身的语言来构建很多工具和流水线。动作向 TA 和特效向 TA 推荐使用。
* Houdini：原本是一个特效软件，现在多用于制作程序化流程。需要注意的是，Houdini 的工作其实是建立在传统的工作流之上的，起到的是锦上添花的作用，他并不能完全取代 MAX 和 MAYA 的地位
* Blender：开源软件、功能齐全。
大厂少使用 Blender 的原因：
    * 公司已经有了自己的 MAYA 和 MAX 的工作流和一些成熟的插件，如果要换成本太高；
    * 如果使用 Blender 基本无法与同组的其他成员进行文件交流；
    * 因为 Blender 本身开源，背后没有足够强大的公司做专业支持，公司自己需要产品团队帮助时，如果网络上无人研究，公司就需要耗费成本去自行研究或者等软件更新，而 MAX 和 MAYA 背后都有 AutoDesk 的专业团队来帮助公司解决问题。

## 1.2 常用贴图软件
Substance 三件套：SP、SD、SA
* Substance Painter：与 PS 操作的内在逻辑一模一样，美术好上手
* Substance Designer：程序化贴图，贴图构建基于节点设置，做出来的贴图复用性强
    * SD 艺术家推荐：[ArtStation-Daniel Thiger](https://www.artstation.com/dete)
* Substance Alchemist：炼金术士，可以比较方便地修改自己的程序和资源，并且结合了如生成法线、生成高度图、扫描法线等小工具
* Quixel Mixer：操作逻辑和 SP 差不多，有一个基于高度混合的特点很好用

贴图重要的是自己的美术和审美能力，上述也只是工具，提高审美和美术功底才是王道。

## 1.3 美术常用工具
找资源、找工具也是 TA 的本职之一，自己也需要锻炼自己去找工具的能力
* 拆分 UV 的工具 — RizomUV ： [RIZOMUV - UV Mapping 3D Software - RIZOM-LAB](https://www.rizom-lab.com/)
* BANJIAJIA 渲梦工厂：[渲梦工厂 - 扮家家版](http://rdf.banjiajia.com/)
    * 有很多功能性工具，比如说检查丢失资源、资源处理、改路径名、重命名、检查重叠物体、模型重面等，推荐工具向 TA 看一看
* 打直 [UV — Unfold 3D：UNFOLD3D® 2019 - UV Mapping Solution](http://www.polygonal-design.fr/e_unfold/index.php)


-------------------------------------------------------------------


# 2. 模型基础

## 2.1 基本建模流程

建模 → 贴图绘制 → 渲染

![基本建模流程](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241207104402.jpg)

**建模**：由MAYA，3DS MAX ，Blend，C4D，ZBrush，这几款市面上相对于比较主流的建模软件来制作。
补充：关于布料的模型解算可以用Marvelous Designer 10 Personal来快速制作布料

**贴图绘制**：
* Substance Painter更加适用于游戏领域
* Mari更加适用于影视领域
* 同等贴图大小下，Mari比Substance Painte绘制的精度高但是没有Substance Painte简单快捷
* PS也可以绘制贴图
* 补充：
    1.Knald法线生成AO以及CV的效果有时候会比Substance Painte好。
    2.Mudbox映射生成皮肤置换贴图，提升模型真实度。

**渲染流程**：
* Arnold为无线渲染器，渲染起来简单高效，建议使用。
* Vray为有线渲染器，与无线渲染器区别不大，速度更快，3S效果没有Arnold好。
* 八猴渲染器，实时渲染器，且八猴4支持光学追踪。
* UE4、Unity，都属于实时渲染引擎。


## 2.2 次时代建模基本流程
中模 → 高模 → 拓扑 → 低模 → 展uv → 烘焙贴图 → 制作材质 → 渲染输出

1. **中模**：最重要的阶段，确定原画比例关系，抓准形体，通过软件建立模型，全方位对比，角色模型比较头身比来抓形，确定了大体poss，然后确定装备比例，通过剪影的方式，确定感觉。同时也要注意布线围绕结构，不能出现五边面，**尽量为均匀四边面**，同时为了动作绑定方便，**关节部位要做三环线**，在这个阶段做的越好在高模阶段越轻松。

2. **高模**：在完成中模的情况下，进一步细化模型，还原原画细节，兼顾比例大小，提高相似度，根据情况对模型修正，违背物理规律的需要修改的合理，在进zb之前对模型进行检查，多点，重合面，坐标归零。ZB中要注意剪影形状。
    * 需要控制模型的面数10w-20w，雕刻布料、皮革的起伏褶皱
    * 面数50w-100w，雕刻破损，做出陈旧感磨损
    * 模型精度不能高于200w面

3. **拓扑**：通过拓扑的手段得到低模（maya\ZB）

4. **低模**：保证低模的物线比较均匀和少量的布线作为基础模型，尽量匹配高模。
    * 如需绑定，那需要裸模的布线进行修改。
    * 如需布料模拟，则需要低模比较好的四方面的布线，要比较均匀，匹配高
    * 匹配的时候，需要在高模和低模上面的剪影去作为一个穿插得到较好的细节，可以使用红绿球来进行检查

5. **展uv**：要尽量分布平整，尽量提高uv的使用率(95%)不允许有太大的缩放差距。一般用棋盘格作为检查
    * 分完之后，看项目需不需要打直，如果像枪械机械等，该需要打直的uv就需要打直。
    * 打直uv一般建议maya拆完之后，输出后unfold3D里进行打直

6. **烘焙贴图**：八猴或者SP烘培法线，八猴精度比在SP里烘焙要高，并且可以对烘焙出来的法线进行一些修正，建议使用八猴。

7. **制作材质**：SP制作贴图的好处是有智能贴图，调整参数就行，耗时短，需要符合PBR流程的规范性，SP自带一个PBR的检查滤镜

8. **渲染输出**：要求不高的直接SP渲染。需要好的效果可以用Arnold或者八猴打光渲染，或者在引擎中搭建场景渲染。


###  次时代基本流程示意图

![次时代建模基本流程示意图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241207111836.jpg)

* 高模阶段：通过各种方法让细节足够多
* 低模阶段：通过拓扑手段以极低的面数把高模进行包裹
* 烘焙阶段：烘焙法线贴图和AO贴图，烘焙完后进入到绘制贴图
* 贴图部分：一般使用PBR流程，也就是基于物理的渲染过程

### PBR
详细参考：https://zhuanlan.zhihu.com/p/53086060

PBR：Physically Based Rendering 基于物理的渲染过程，是一种着色和渲染技术，用于更精确的描述光如何与物体表面互动，由于其高度的易用性以及方便的工作流，已经被电影和游戏业界广泛使用。

而PBR的工作流程主要分为两种：
1. 基于金属的工作流(Metal-Roughness)
2. 基于镜面反射的工作流(Specular-Glossiness)

它们都遵循着PBR的核心原理，最大的区别是如何识别反射与漫反射。
两种工作流传统材质的贴图为法线（Normal）、环境光遮蔽（Ambient Occlusion）、高度（Height）贴图。

* **法线（Normal）贴图**：用于模拟表面细节，在非PBR流程中用法相同
* **环境光遮蔽**（Ambient Occlusion）：用于计算因遮蔽而造成的光线衰减的效果，模拟模型的各个面之间的距离
* **高度（Height）贴图**：用于视差映射，为凹凸/法线贴图额外提供了更明显的深度，增强真实性。

除了这三张通用贴图，根据工作流程不用所使用到的其他贴图也不同。

**基于金属的工作流 Metal / Roughness**
M-R工作流的特定贴图有基色（BaseColor）、金属度（Metallic）和粗糙度（Roughness）贴图。
* 基础色（BaseColor）贴图：保存了金属的反射率和非金属的反射颜色，包含RGB三通道。不包含其他光照信息。
* 金属度（Metallic）贴图：描述哪些区域是金属，那些是非金属。黑色区域为非金属，白色区域为金属。
* 粗糙度（Roughness）贴图：描述表面引起光纤漫反射的不规则程度。在粗糙度贴图中，黑色表示光滑表面，白色表示粗糙表面

**基于镜面反射的工作流 Specular / Glossiness**
S-G工作流的特定贴图有漫反射（diffuse）、镜面反射（specular）、光泽度（glossiness）贴图。
* 漫反射（diffuse）贴图：保存非金属的反射颜色，包含RGB三通道。但它不包含任何反射值，因此金属区域将是黑色。
* 镜面反射（specular）贴图：定义了金属的反射率值，用来表现当光线照射到模型表面时,其表面属性。俗称高光贴图。
* 光泽度（glossiness）贴图：和M-R工作流中粗糙度相反，白色表示光滑表面，黑色表示粗糙表面。

M-R工作流因为其更容易制作和纹理暂用内存少的贴图使用得更多。


## 2.3 角色建模

流程：基本人体 → 人头 → 装备 → 头发基本体 → 人头细化 → 装备细化 → 贴图 → 环境测试 → 输出完成

1. 基本人体：Make human或者DAZ
    * Make human：完成度先对低布线好。
    * DAZ：有绑定系统，完成度高。

2. 人头：一定要抓好大型

3. 装备：确定好比例关系

4. 头发：确定好剪影大型


角色建模基本流程示意图：

![角色建模基本流程示意图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241207120919.jpg)

### 灯光测试环境： 

![灯光测试环境](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/aad18080-152e-49e8-b9dd-31ac88df041e.png)

1. 确定灯光强度，色温，方向颜色是否与我们需要的一致 。
2. 确定灯光的位置
3. 色卡079与SRGB，辅助材质贴图颜色控制不要有太高饱和度，以及方便后期调色。
4. HDR作为资产的环境光以及主要灯光测试模型。


----------------------------------------------------------------------------


# 3. 硬表面基础

## 3.1 什么是硬表面
* 从外表/建模来说：有着重工业质感、该平滑的时候平滑，该硬朗的时候硬朗。即平的平，弯的弯。
* 从光影来说：光影变化均匀，硬朗，有经过打磨的感觉。
* 需要区别于LowPoly，Lowpoly有种纸片的拼凑感，更像是纸膜，主要是倒角所给予硬表面的厚度。即缺少最重要的倒角。

![硬表面](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210200201.jpg)

不只是有棱角的东西感觉会硬，光滑的曲面也可以很硬

![光滑的曲面](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210200710.jpg)


有些情况下看起来就不硬。比如衣物、人的面部等等，还有还有下图第四张的金属，看起来凹凸不平的，给人的感觉就比较薄。
其特点和硬表面都是相反的，即表面光影变化突兀。

![非硬表面](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210201221.jpg)


## 3.2 如何制作硬表面

在游戏中硬表面通常是使用低模进行体现。因为硬表面的质感很大程度上取决于倒角。倒角会很大的增加模型面数。对于一些较小的结构，小凹槽，实际在低模上进行倒角或者卡边做出结构是不太划算的，通常是通过高模烘焙法线贴图来实现。

本质上是要让高光的呈现更加集中，如果高光过于散开，就会显得较软，漂亮的高光边会表现很强的质感。

![硬表面和非硬表面对比](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/39e7f061-e753-412c-a7a4-c162d5694ef7.jpg)


### 具体实现

1. 卡单线+平滑：能达到对高光进行限制的效果，但是还不是很漂亮。
    ![卡单线+平滑](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210203454.jpg)
2. 卡双线+平滑：能达到很漂亮的高光边。
    ![卡双线+平滑](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210203813.jpg)
3. 直接倒角：可能得到漂亮的高光边，但是因为增加的边数很多，过于密集，修改起来麻烦。
    ![直接倒角](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210204305.jpg)
4. 方倒角：两个小倒角夹住一个平面，本质和前面是差不多的
    ![方倒角](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210204612.jpg)
5. 点法线/软硬边：给两个模型一个光滑组，通过加线的方式把高光收束。是低模追求硬表面效果的很好的表现形式。
    ![点法线/软硬边](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241210205629.jpg)


## 3.3 烘焙法线

烘焙前要设置好光滑组（Maya里叫软硬边），并且硬边需要断开uv，否则烘焙出来会有接缝。

![烘焙法线](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/c7ac8786-6123-4a5c-b398-fea30c82e9a7.jpg)

如果统一了软边，即使用光滑组，法线烘焙出来是有渐变色的。这是需要避免的，在有Lod的情况下会很难处理。会造成光影信息的不对应。

![烘焙法线](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/e094c4b9-a5ec-4988-8e86-b7c3707300fa.jpg)

所以将法线信息烘焙至低模时，要记得设置好光滑组，并且硬边需要断开UV，否则会有白边的情况，因为硬边其实存在两个方向的法线信息，光影/法线信息不可能在一个像素内就产生平滑的变化。


## 3.4 一些取巧的方法
一些“旁门左道”，更高效快速地实现效果
* 假高模
* 用图片转normal
* 在SP里面印normal
* 使用OpenSubdiv
* 使用ZBrush做倒角
* 使用点法线


----------------------------------------------------------------


# 4. 



------------------------------------------------------------------


# 5. 模型常见问题及规范

## 5.1 布线的合理性

**动画角度**：
* 横平竖直，均匀清晰，结构线密度足够（动画线一般为三根）
* 动画线及关节线：脖子，肩膀，肘关节，腰，膝关节，踝关节
* 由于肘关节和膝关节一般是单向弯曲，所以在面数有限的情况下，也可以使用前三后二的布线

**模型角度**：尽量把线使用在体现剪影上，单纯的在平面上加线是没有意义的，平面上的细节会在之后的制作中用法线来体现

#### 多星点问题
如果是在中模阶段，减少使用多星点，因为会在细分时出现凸点的问题，如果要使用多星点，请通过布线技巧把它移动至平面出，不要让它出现在倒角边缘。

![多星点问题](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241212213942.jpg)


#### 五星点问题
在模型上挖洞，且要保证都是四边面的情况下，是必然会出现五星点的，五星点不可避免，但可以优化。也有把五星点转换为假四边的方法（模型师把这种布线叫做假四边）

对于布线的合理性，大部分情况下都是指的低模，在次世代流程中，高模只需要做出效果，布线可以随意的来，因为高模的用途只是为了一张法线贴图

这里说一下五星点(拥有5条边的点)对于法线的影响。

在三维软件里，一般对于点法线的算法都有预设，maya中对于点法线算法为:无权重、角度权重、面积权重、角度面积混合权重

由于点法线是通过面法线计算的，因为所属四边形被切割，计算时其中一个面面积减少了(从原来的1+2，变成了1)，所以导致点法线的方向出现了偏移(没切前法线方向应该为红色)，进而会影响到后期的烘焙效果

![20241212215141](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241212215141.jpg)



## 5.2 UV合理性

UV的合理主要是为了提高精度，也就是在资源有限的情况下，达到更好的效果

UV基础规范：如果是使用UDIM（多象限UV），从【0,1】框开始依次摆放，正常情况下全部UV放于【0,1】框内，虽然UV是平铺的，但是我们常用的软件，例如SP，绘制过程中，只能在【0,1】框中绘制

![UV绘制](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/19122152-fc2c-4427-b2a7-0e79076180dc.png)

#### 打直UV
**打直UV能使我们更好的利用空间**，提高空间利用率，这也是为什么合理利用UV可以提高精度，能打直的打直，能横竖打直的就不要斜打直，像素化懂的都懂，斜打直会成为锯齿的根源

![打直UV](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/ff095f79-c55f-4f39-848e-493c9f5ec0ae.png)

#### UV拉伸
**一般在为了提高利用率的情况下UV是允许有均匀拉伸的**，特别是如果后期不会出现纹理制作的情况下，均匀拉伸不会存在任何问题，在精度够的情况下，拉伸也是没有问题的，只是你制作出来的贴图最后也会是拉伸的

我们一般是使用棋盘格来检查UV的拉伸是否合格，同样带数字的棋盘格也可以拿来检查UV的方向是否和模型方向一致，虽然正放倒放不影响贴图制作，但是行业默认能和模型一致就和模型一致展开UV

![UV拉伸](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241212220142.png)

在烘焙时，如果有公用的UV需要挪出【0,1】框，如果不挪出去烘焙时会识别不了你需要烘哪一边作为结果，导致得到的法线贴图出现错误

#### 接缝问题
**硬边的地方UV必须断开**，UV边界才能按正确的法线去烘焙，否则烘焙出来的法线贴在模型上必然会出现接缝（不可修复），关于硬边和光滑组在下一节有介绍

对于UV的接缝问题，有些事无法处理或不好处理的，而有些是在制作时可以避免的。有些人为处理就可以比较好的避免接缝问题。

UV接缝的两侧最好是对齐状态，这在你使用Tiing贴图时会发现格外重要

![UV接缝问题](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241212220958.jpg)

如果出现了UV接缝一般情况都是接缝两边UV精度不同导致的，所以统一精度能避免大部分接缝


## 5.3 光滑组

可参考上面第三节的内容

光滑组是中通过对面的定义来定义软硬边
软边就是如果点处于不同平面时，点会获得所在平面的平均法线，硬边这是拥有多个方向的法线（如图）

![软硬边法线示意图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241212221550.png)

![3Dmax中光滑组](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20241212221841.png)

一个平面可以有多个光滑组，只要相邻面共同拥有一个光滑组，相交边就会是软边效果

值得注意的是，在三维软件中（maya，max）导出模型法线会处于锁定状态，而导入模型后解锁法线，由于maya和max定义软硬边的方式不同（maya直接对边定义软硬边，max通过定义面的光滑组定义软硬边），会导致光滑组/软硬边丢失，可以通过插件实现在保持软硬边的情况下解锁法线，也就是先记录软硬边信息再去解锁，解锁后重新赋予即可

由于定义了软硬边，后期的烘焙过程中，烘焙时拾取的是你最后使用的模型的点的法线，如果你在烘焙结束后又去修改了软硬边信息，正常情况下软硬边信息不对等的地方法线会出现错误

## 5.4 模型基本规范

我们制作完模型导出时请检查一下基本信息：
1. 该合并的点全部合完了
2. 没有非法面，N边面等不规范面的存在
3. 有UV，用于贴图
4. 不出现镂空面穿帮
5. 场景大小设置正确
6. 拥有规范命名，方便资产整理（模型一般前缀使用“SM_”，及static mesh）
7. Maya模型请检查历史清除干净没有，Max模型请塌陷编辑器
8. 模型的坐标轴归零（习惯问题，否则进入引擎后你可能法线坐标轴不在你模型的周围）
9. 进入引擎前最好三角面化


## 5.5 常见问题

* **SP导入模型时出错**（可能是没有UV，UV没在（0,1）框内等等，SP的log里面一般会把报错原因直接写出来）
* **Maya里制作的模型导入Max（或者反向导入），赋予软硬边缺没有效果变化**（导出模型时发现会被锁定，所以请先解锁法线，再重新定义软硬边）
* **Maya里制作的模型导入Max（或者反向导入），发现模型大小不一致**（检查maya和max的场景单位设置是否一致）
























































































































