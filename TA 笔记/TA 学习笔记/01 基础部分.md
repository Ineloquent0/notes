Unity Shader 入门精要部分笔记记得比较详细，这里的笔记就简单记一下重点部分，就当复习一下。

# 1. 渲染流水线

![渲染流水线流程](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240830212340.jpg)

整体流程：应用阶段 -> 几何阶段 -> 光栅化阶段 -> 逐片元操作 -> 后处理

1. **应用阶段**：粗粒度剔除，进行渲染设置，准备基本数据，输出到几何阶段
    1. **准备场景数据**
        * 场景物体数据
            * 物体变换数据：位置、旋转、缩放等
            * 物体网格数据：顶点位置、UV贴图等
        * 相机数据
            * 位置、方向
            * 远近裁剪平面
            * 正交/透视（FOV）
            * 视口比例/尺寸等
        * 光源及阴影数据
            * 光源类型：点光源、平行光源、聚光灯等
            * 位置、方向、角度等其他参数
            * 设置阴影：是否需要阴影、阴影参数（对应光源序号、阴影强度、级联参数、深度偏移、近平面偏移等）
            * 逐光源绘制阴影贴图：近平面偏移、逐级联（计算当前光源+级联对应的观察矩阵、投影矩阵、以及对应到阴影贴图里的视口区域，绘制到阴影贴图）
        * 其他全局数据
    2. **加速算法，粗粒度剔除**
        * 碰撞检测
        * 加速算法
        * 遮挡剔除
            * 可见光裁剪
            * 可见场景物体裁剪：八叉树、BSP树、K-D树、BVH
        * 其他算法
    3. **设置渲染状态，准备渲染参数**
        * 绘制设置
            * 合批方式
        * 绘制顺序
            * 相对相机的距离
            * 材质渲染队列（Render Queue）
            * UICanvas
            * 其他方式等
        * 渲染目标
            * FrameBuffer
            * RenderTexture
        * 渲染模式
            * 前向渲染（Forward Rendering）
            * 延迟渲染（Deferred Rendering）
    4. **调用 DrawCall ，输出渲染图元到显存**
        * 顶点数据：位置、法线、UV、颜色、其他顶点数据
        * 其他数据：MVP变换矩阵、纹理贴图、其他数据
2. **几何阶段**：顶点着色器，曲面细分，几何着色器，顶点裁剪，屏幕映射
    1. **顶点着色（Vertex Shading）**
        * **视图变换（MVP变换）**：模型空间 $\stackrel{模型变换}{\longrightarrow}$ 世界空间 $\stackrel{视图变换}{\longrightarrow}$ 观察空间 $\stackrel{投影变换}{\longrightarrow}$ 裁剪空间
        * **顶点着色**：计算逐顶点光照等等
    2. **可选顶点处理**
        * **曲面细分（可选）**：利用顶点着色器输出的顶点，按照一定的规则和算法，生成更多的顶点，将现有的网格和图元细分
        * **几何着色器（可选）**：基于图元的操作，通过给定的图元生成更多的图元
    3. **投影（Projection）**：对于顶点在裁剪空间的位置 xyzw，对它进行一个透视除法，把 xyz 除以 w 来完成投影操作。这样就从投影坐标系转换到标准设备坐标系（NDC）
        * 正交：w 始终为1，所以投影到屏幕上时，不论远近 xyz 不变
        * 透视：w 近处较小，远处较大，所以投影到平面上会呈现出近大远小的效果
    4. **裁剪（Clipping）**：对于 NDC 下的顶点位置，xyz 不在 [-1, 1] 范围内的，就是在裁剪空间以外的，会舍弃掉。图元部分在裁剪空间外的，会生成两个额外的顶点补全图元
        * CVV（Canonical View Volume）
        * 正面或背面剔除（可配置）
    5. **屏幕映射（Screen Mapping）**：将标准坐标系下的顶点坐标映射到屏幕坐标系下
        * 从连续到离散
        * 坐标系差异（OpenGL/D3D）
3. **光栅化阶段**：三角形（点/线）设置，三角形（点/线）遍历，片段着色器
    1. **三角形设置（Triangle Setup）**：计算图元的边界信息
    2. **三角形遍历（Triangle Traversal）**：寻找被三角形网格所覆盖的所有像素，然后使用三角形顶点对覆盖像素进行线性插值，得到对应的片元数据
    3. **抗锯齿（Anti-Aliasing）**
        * SSAA：渲染到一个分辨率放大 n 倍的 buffer，对放大 n 倍的 buffer 下采样
        * MSAA：对 SSAA 的优化，对每个像素设置多个子采样点，并进行覆盖测试和遮挡测试，保存信息在最后逐片元进行混合
        * FXAA/TXAA：后处理技术，不在这个渲染阶段
4. **逐片元操作**：裁剪测试、透明度测试、深度测试、模板测试，混合
    1. **片元着色（Fragment Shading）**：根据顶点颜色进行插值
    2. **颜色混合（Color Blending）**
        * Alpha Test：透明度小于透明度阈值的片元将被舍弃
        * Depth Buffer Test：将片元深度值和深度缓冲区的深度值进行比较，通过测试的则保留（可自行决定是否更新深度缓冲区）
        * Stencil Test：模板测试，比较模板值，通过模板测试的片元将被保留（可自行决定是否更新模板缓冲区）
        * Blending：颜色混合
    3. **目标缓冲区（FrameBuffer）**
        * FrameBuffer
        * RenderTexture
5. **后处理**：对最后输出的缓冲区/渲染贴图进行处理。


--------------------------------------------------------------------


# 2. 数学基础

可以参考另一篇笔记： [Games101 笔记 - 数学基础部分](https://github.com/Ineloquent0/notes/blob/main/Computer%20Graphics/01%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80.md)


## 2.1 向量运算

### 认识向量

**向量的定义：**
* 向量是有大小和方向的有向线段
* 没有位置只有大小和方向
* 向量的箭头是向量的结束，尾是向量的开始
* 向量描述的位移能够被认为是与轴平行的位移序列
* 向量表示：三维 $(a_x, a_y, a_z)$ ，二维 $(a_x, a_y)$

**向量与标量**
* 向量：有大小和方向的有向线段
* 标量：只有大小，没有方向的量

**向量与点**
* 向量和点数学形式上相等，但几何意义完全不同。
* 向量：无位置，有实际大小和方向。
* 点：有位置，没有实际大小或方向。
* 联系：任何一个点都可以看做是从原点出发的向量。

**零向量**
* 零向量是唯一大小为零的向量
* 零向量是唯一一个没有方向的量
* 零向量不是一个点，因为没有定义某个位置
* 零向量表示的是没有位移，就像零标量表示的是没有数量一样


### 向量的计算

**标量与向量的运算**
* 没有加减
* 乘法：将每个分量都与标量相乘（例：$-2(2, -5) = (-4, 10)$）
* 除法：等同于乘以标量的倒数（例：$(6, -2, -4)/2 = (3, -1, -2)$）
* 乘除的几何意义：以标量的大小缩放向量的长度，负值则方向相反（将向量缩放至 k 个标量单位）

**向量的模长**： $\|v\| = \sqrt{v_x^2 + v_y^2 + v_z^2}$

**标准化向量（单位向量）**： 
* 大小为 1 的向量，用于只需要知道方向，不关心大小的向量。例如：法线
* 运算法则：将向量除以它的模长： $\hat{v} = \frac{v}{\|v\|}, v \neq 0$

**向量与向量的运算**
* 加法：对应位置相加（例： $(1, -4) + (7, 5) = (8, 1)$ ）
* 减法：对应位置相减（例： $(-3, 6) - (-4, 3) = (1, 3)$ ）
* 点乘：
    * 公式： $(a_x, a_y, a_z) \cdot (b_x, b_y, b_z) = a_x b_x + a_y b_y + a_z b_z$
    * 几何意义：
        * 点乘结果描述了两个向量的相似程度，点乘结果越大，夹角角度越小，两个向量越接近。 $\vec{a} \cdot \vec{b} = \| \vec{a} \| \| \vec{b} \| \cos \theta$
        * 用于计算投影
    * 满足交换律： $\vec{a} \cdot \vec{b} = \vec{b} \cdot \vec{a}$
* 叉乘：
    * 仅用于3D向量： $(a_x, a_y, a_z) \times (b_x, b_y, b_z) = (a_y b_z - a_z b_y, a_z b_x - a_x b_z, a_x b_y - a_y b_x)$
    * 几何意义：
        * 叉乘得到的向量垂直于原来的两个向量。
        * 用于判断点是否在三角形内部。
    * 不满足交换律，满足逆交换律： $\vec{a} \times \vec{b} = -(\vec{b} \times \vec{a})$
    * 叉积的大小与方向判断： $\|\vec{a} \times \vec{b}\| = \|\vec{a}\| \|\vec{b}\| \sin \theta$

**计算两点间距离：距离公式**
* 3D 距离公式： 距离 $(a, b) = \|b-a\| = \sqrt{(b_x-a_x)^2 + (b_y-a_y)^2 + (b_z-a_z)^2}$

**向量投影**
$\vec{b}$ 在 $\vec{a}$ 上的投影为： $\vec{b}_\perp = \frac{\vec{a} \cdot \vec{b}}{\|a\|^2} \hat{a}$

**兰伯特光照模型**
* 兰伯特光照模型是目前最简单通用的模拟漫发射的光照模型
* 使光照方向的反方向为 L 向量，法线方向为 N 向量，则有：
    * L 与 N 方向相同，则 Normal · Light = 1（纯亮）
    * L 与 N 方向相反，则 Normal · Light = -1（纯黑）
    * L 与 N 方向垂直，则 Normal · Light = 0（纯黑）



## 2.2 矩阵运算

### 矩阵的概念

#### 线性方程
一次方程，没有 sin、cos 这些
* 可加性： $f(x_1 + x_2) = f(x_1) + f(x_2)$
* 比例性： $f(kx)= k f(x)$

**线性空间**：直线变换后依然是直线，并且等比或等距，坐标原点保持不变

**非线性空间**：空间扭曲，不是等距，坐标原点有位移

#### 矩阵的定义
由 m x n 个数 $a_{ij}(i = 1,2,3...m;j=1,2,3...n)$ 排成的 m 行 n 列的数表称为 m 行 n 列矩阵，简称 m x n 矩阵。为表示这些数字是一个整体，总是加一个方括号

$$
A =
\begin{bmatrix}
a_{1,1} & a_{1,2} & \cdots &a_{1,n}\\
a_{2,1} & a_{2,2} & \cdots &a_{2,n}\\
\vdots & \vdots & \ddots & \vdots\\
a_{m,1} & a_{m,2} & \cdots &a_{m,n}\\
\end{bmatrix}
$$

#### 特殊的矩阵
* 方阵：行数列数都相等，且都等于 n 的矩阵成为 n 阶矩阵或 n 阶方阵。例： $\begin{bmatrix}
a & b\\
c & d\\
\end{bmatrix}$
* 单位矩阵 $I$ ：n x n矩阵，从左到右的对角线上的元素是1，其余元素都是0。例： $\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1\\
\end{bmatrix}$
* 零矩阵 $O$ ：元素都是零的矩阵。例： $\begin{bmatrix}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0\\
\end{bmatrix}$
零矩阵不相等，虽然各个元素都为0，但是元素的位数不同，所以不等
* 正交矩阵：如果一个方阵 A 和 它的转置矩阵的乘积是单位矩阵的话，我们就说这个矩阵是正交的： $A^T A = A A^T = I$ 


### 矩阵的运算

#### 矩阵加减
* 加法：对应位置相加，只有同型矩阵（同行同列）才能相加
    * 交换律： A + B = B + A
    * 结合律： (A + B) + C = A + (B + C)
* 减法： A - B = A + (-B)
* 几何意义：对单位向量的一个变换


#### 矩阵乘法

**常数与矩阵的乘法**：
* 矩阵与常数相乘：矩阵中每个元素乘以常数
* 几何意义：对空间的缩放

$$
kA = Ak =
\begin{bmatrix}
ka_{1,1} & ka_{1,2} & \cdots & ka_{1,n}\\
ka_{2,1} & ka_{2,2} & \cdots & ka_{2,n}\\
\vdots & \vdots & \ddots & \vdots\\
ka_{m,1} & ka_{m,2} & \cdots & ka_{m,n}\\
\end{bmatrix}
$$


**矩阵与矩阵之间的乘法**：

* 不是所有矩阵都能相乘，矩阵相乘需要满足一定的合法性
* m * n 的矩阵只能与 n * p 的矩阵相乘（第一个矩阵的列数等于第二个矩阵的行数），得到的矩阵大小为 m * p
* 得到的结果的第 i 行第 j 列的元素是：第一个矩阵第 i 行的元素与第二个矩阵第 j 列的元素的点乘结果
* 几何意义：进行矩阵变换，更改单位向量（转换到新的坐标系）
* 不满足交换律，矩阵的相乘是有顺序的，是从右向左乘的

例：

$$
\begin{bmatrix}
2 & 1\\
0 & 3\\
5 & 4\\
\end{bmatrix} *
\begin{bmatrix}
7 & 6\\
8 & 9\\
\end{bmatrix} =
\begin{bmatrix}
2*7+1*8 & 2*6+1*9\\
0*7+3*8 & 0*6+3*9\\
5*7+4*8 & 5*6+4*9\\
\end{bmatrix} =
\begin{bmatrix}
22 & 21\\
24 & 27\\
67 & 66\\
\end{bmatrix}
$$


#### 常见的矩阵

* 纵向拉伸矩阵： $\begin{bmatrix} 1 & 0 \\ 0 & k \end{bmatrix}$
* 斜切矩阵： $\begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix}$
* 基于 y = x 镜面对称： $\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$
* 缩放矩阵： $\begin{bmatrix} x & 0 \\ 0 & y \end{bmatrix}$
* 旋转矩阵： $\begin{bmatrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{bmatrix}$
* 位移矩阵： $\begin{bmatrix} 1 & 0 & x \\ 0 & 1 & y \\ 0 & 0 & 1 \end{bmatrix}$
位移矩阵不是线性变换，是仿射变换。

#### 三维空间中的坐标变换

缩放（Scale）： 

$$
S_{(s_x, s_y, s_z)} = 
\begin{bmatrix} 
s_x & 0 & 0 & 0 \\ 
0 & s_y & 0 & 0 \\ 
0 & 0 & s_z & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$


移动（Translation）：

$$ 
T_{(t_x, t_y, t_z)} = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\ 
0 & 1 & 0 & t_y \\ 
0 & 0 & 1 & t_z \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$


绕x、y、z轴旋转：

$$
R_{x}(\theta) = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\ 
0 & \cos\theta & -\sin\theta & 0 \\ 
0 & \sin\theta & \cos\theta & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$

$$
R_{y}(\theta) = 
\begin{bmatrix}
\cos\theta & 0 & \sin\theta & 0 \\ 
0 & 1 & 0 & 0 \\ 
-\sin\theta & 0 & \cos\theta & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$

$$
R_{z}(\theta) = 
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0 \\ 
\sin\theta & \cos\theta & 0 & 0 \\ 
0 & 0 & 1 & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$


#### 矩阵的转置
矩阵的转置就是把矩阵的行列互换，记作 $A^T$ 

矩阵的转置有以下性质：
$(A^T)^T =A$
$(AB)^T = B^TA^T$
$(A+B)^T=A^T + B^T$

#### 逆矩阵
矩阵与它的逆矩阵相乘，得到单位矩阵，常用作矩阵变换后再次矩阵变换回原来的的初始位置

![逆矩阵](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240901185910.jpg)

$$
I = A^{-1}A = AA^{-1}
$$

**逆矩阵的运算规律**
* 逆矩阵的逆矩阵就是原矩阵本身，假设矩阵A是可逆的 $（A^{-1}）^{-1} = A$
* 若A可逆，数 λ≠0，则 λA 可逆 $（λA）^{-1} = \frac{1}{λ}A^{-1}$
* 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵 $（AB）^{-1} = B^{-1}A^{-1}$
这个性质可以扩散到更多矩阵的连乘 $(ABCD)^{-1} = D^{-1}C^{-1}B^{-1}A^{-1}$
* 转置矩阵的逆矩阵是逆矩阵的转置 $（A^T）^{-1} = (A^{-1})^{T}$

## 2.3 MVP矩阵

MVP：模型（Model）、视图（View）、投影（Projection）

模型空间（Local Space） $\stackrel{模型变换(M)}{\longrightarrow}$ 世界空间（World Space） $\stackrel{视图变换(V)}{\longrightarrow}$ 观察空间（View Space） $\stackrel{投影变换(P)} \longrightarrow$ 屏幕空间（Screen Space）

#### M 矩阵

模型变换矩阵，将物体从局部坐标系转换到世界坐标系
* 模型空间：以自身中心为原点的空间坐标系
* 世界空间：以世界中心为原点的空间坐标系

$$
M =
\begin{bmatrix}
1 & 0 & 0 & tx\\
0 & 1 & 0 & ty\\
0 & 0 & 1 & tz\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
cos\theta & 0 & sin\theta & 0\\
0 & 1 & 0 & 0\\
-sin\theta & 0 & cos\theta & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
kx & 0 & 0 & 0\\
0 & ky & 0 & 0\\
0 & 0 & kz & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

#### V 矩阵

视图变换矩阵，将物体从世界坐标系转换到观察坐标系
* 观察空间：以摄像机位置为原点的空间坐标系

$$
V =
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & cos \theta & -sin \theta & 0\\
0 & sin \theta & cos \theta & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & tx\\
0 & 1 & 0 & ty\\
0 & 0 & 1 & tz\\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

#### P 矩阵

投影变换矩阵，将物体从观察坐标系转换到屏幕坐标系
* 屏幕空间：以屏幕左下角为原点的空间坐标系

1. 不是真的投影，为投影做准备
2. 目的：判断顶点是否在可见范围内。
3. P矩阵：对 x,y,z 分量进行缩放，用 w 分量做范围值。如果 x,y,z 都在 w 范围内，那么该点在裁剪空间内。


------------------------------------------------------------------


# 3. 纹理基础

可参考 Games 101 第9节：[Games 101 笔记 - 纹理映射](https://github.com/Ineloquent0/notes/blob/main/Computer%20Graphics/02%20%E5%85%89%E6%A0%85%E5%8C%96.md#52-%E5%BA%94%E7%94%A8%E7%BA%B9%E7%90%86-applying-textures)

## 3.1 纹理的概念
纹理是一张图片，是一种可供着色器读写的结构化存储形式

牺牲几何细节，提升建模工作量、存储空间、读取速度。

**纹理管线**

模型空间位置 => 投影函数 => 纹理映射 => 纹理坐标 => 通讯函数 => 新纹理坐标 => 纹理采样（避免依赖纹理读取） => 纹理值

> * **投影函数**：获取我们要渲染的位置，将它从模型空间投影到纹理空间中，转化为 UV 坐标（投影指的是纹理投影，不同于摄像机投影，常规情况下投影函数通常会在 “展 UV” 的阶段中使用，将投影的结果存储在顶点数据中。所以通常我们是直接使用存储在模型顶点数据中的投影的结果）
> * **通讯函数**：将 UV 坐标进行一个灵活的扩展，实现平移缩放旋转或者是控制图像的应用方式等等，得到一个新的纹理坐标，用这个纹理坐标就可以去获取纹理的值了（纹理采样）
> * 着色器中的纹理通常会以 Sampler Variable（采样器变量）的形式存在，即我们经常看见的 sampler，这是一种 Uniform 类型的变量，在处理不同片元时这个变量是不变的。
> * **依赖纹理读取**：当我们使用 tex2D 或类似方式去访问纹理时，只要 fragment shader 不是直接用 vertex shader 传过来的数据，而是需要计算的数据，那么他就会产生一个叫做依赖纹理读取的东西，哪怕这个处理只是简单的交换 UV 的两个坐标。**只要不是顶点着色器传过来的纹理采样数据，在片元着色器需要计算纹理偏移，哪怕是只进行了一些计算，也会影响性能的表现。**

![纹理管线](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902093018.jpg)



## 3.2 纹理采样设置

#### Wrap Mode 平铺模式
决定 UV 值在 [0,1] 以外的表现
OpenGL -- "包装模式"(Wrapping Model)
DirectX  -- "纹理寻址模式"(Texture Addressing Mode)

![Wrap Mode](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902092351.jpg)

#### Filter Model 过滤模式
当纹理由于变化而产生拉伸时，要采用哪种滤波来调整它自身的表现

![Filter Model](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902094436.jpg)

* **最邻近**：读取它最近的纹素（效果类似像素化），消耗最低
* **双线性**：找到相邻的四个点，进行线性插值，来得到这个像素的混合值
* **立方体卷积插值**（也叫双三次插值）：不仅考虑到周围四个相邻像素点的影响，还考虑到它们变化率的影响，共采样16个点，根据它们与中心像素的距离，来带入到不一样的公式区运算它们对这个位置的影响值。效果最好，消耗最大。

![立方体卷积](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902095911.jpg)

* **Lanczos 插值**： Lanczos 核函数来计算插值后的像素值。Lanczos 核函数是一种低通滤波器，可以消除缩放过程中产生的混叠现象。它取了 8x8 个像素来计算，代价很高（感兴趣可以自行了解，这里不做过多介绍）
* **Quilez 的光滑曲线插值**：在立方卷积插值与双线性插值的一个折中效果，画面表现效果要比双线性插值好，比立方卷积插值差，消耗也比立方体卷积小。

![Quilez 的光滑曲线插值](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902102231.jpg)
![光滑曲线插值](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902102307.jpg)

效果对比：

![效果对比](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902102531.jpg)


## 3.3 纹理缩小
纹理缩小时，会出现几个纹理覆盖一个像素的情况，会出现颜色丢失与闪烁。
常见的过滤方法有最邻近和双线性插值，原理与放大的时候一样。

### Mipmap
Mipmap：预处理纹理并创建数据结构，有助于实时工作时快速计算一组纹素对一个像素的近似值，内存比原本多了 1/3

![Mipmap](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902110448.jpg)

**如何选择正确的 level**
使用四个像素单元格所形成的一个四边形的最长边来近似这个像素覆盖的范围，在 GPU 中并不是一个像素一个像素的去渲染执行，而是分成 2x2 一组并行进行处理，这样做的原因是用来计算 ddx  ddy，以及用来计算法线

```
float dx = ddx(i.uv);
float dy = ddy(i.uv);
float lod = 0.5 * log2(max(dot(dx,dx), dot(dy,dy)));

float3 albedo = tex2Dlod(_MainTex, float4(i.uv, 0, lod)).rgb;
```

![Mipmap 如何选择正确的 level](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902110546.jpg)

假设算出来的是 1.8 层，还需要使用三线性插值来得到屏幕像素的最终值。
三线性插值（trilinear interpolation）：两次双线性插值之后，再做一次线性插值。

由于 mipmap 只实现正方形内的范围查找，于是会产生 overblur 的问题：屏幕像素对应材质的长方形甚至斜长的区域，在做 mipmap 时，自然会取过大的正方形，从而导致模糊的情况。

### 各向异性过滤 (Anisotropic Filtering)

![各向异性过滤](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906114126.jpg)

* 允许对长条的区域进行范围查询，但不能用于斜着的区域。
* 生成各向异性过滤的图（Ripmap）的内存开销是原本的三倍。
* 各向异性的意思是：在不同的方向上它的表现各不相同。
* 各向异性的 几x 是压缩的几倍，也就是从左上角往右下角多几层。


#### 积分图 Summed - Area Table
以内存为代价，有效的检索到非正方形区域上的纹素均值。

![积分图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906120538.jpg)

右边表格的数据怎么来的呢？就跟图上上面的公式是一样的
比如2行2列的8就是：2 + 3 + 3 + 0
再比如1行4列的8就是：2 + 3 + 2 + 1
以此类推

#### 其他问题

当我们去 Unity/UE 中开启各向异性过滤之后的纹理内存并不像上面所说的纹理内存会是原来的 3 倍而仅仅是  $\frac{1}{3}$ 而已呢？
* 各向异性过滤是一个总称，RipMap 只是其中一个方法，如果任何一张纹理使用 RipMap 都会扩大纹理内存3倍，在实际项目中是不敢用的
* 从屏幕空间进行反向投影到纹理空间，进行计算，但是这样所需要的计算量是很大的



## 3.4 纹理优化

### CPU 渲染优化常见方式 —— 纹理图集/数组
减少Draw Call，避免渲染时频繁改变纹理带来的消耗

![纹理图集](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906122958.jpg)


### GPU 渲染常见方式 —— 纹理压缩
从带宽入手，显存带宽指 GPU 独显的专用内存的速度，如果游戏速度受限于显存带宽的话，往往是我们所使用的纹理实在太大，GPU 它没有办法快速处理
* 减少了资源在 CPU 中进行解压缩的过程
* 减小了包体大小，减少了数据量级，减轻了带宽计算的压力
* 内存的使用效率更高


## 3.5 纹理应用

### 立方体贴图 CubeMap

![立方体贴图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906123928.jpg)


### 凹凸贴图 Bump Mapping

![凹凸贴图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906124023.jpg)

### 位移贴图 Displacement Mapping
凹凸贴图是模拟，而位移贴图是真的把顶点做了位置的移动

![位移贴图](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906124119.jpg)

代价：要求模型精度高
DirectX 中的动态曲面细分：开始先用粗糙的三角形，应用贴图的过程中检测是否需要把三角形拆分的更细。


-------------------------------------------------------------------


# 4. 主流平台 API 介绍

电脑的工作原理：电脑是由各种不同的硬件组成，由驱动软件驱使硬件进行工作。所有的软件工程师都会直接或者间接的使用到驱动

**API 定义**：是一个图形库，用于渲染2D、3D矢量图形的跨语言、跨平台的应用程序编程接口（API），针对GPU


## 4.1 基础概念

* **应用端**：即我们自己的程序端，相对用 OpenGL ES，我们属于应用端
* **图元**：要渲染的几何物体，或者形状。比如要渲染一个正方形的图片，就是一个图元，要渲染两条直线，这两条直线也是图元
* **纹理**：通俗点，可以理解为一张图片，在 OpenGL ES 中纹理就是图片的另外一种叫法
* **纹素**：纹素是纹理的基础单位，不同于像素，图像是由像素排列而成，纹理是由纹素排列表示的，两个具有本质上的区别
* **顶点数组**：顶点指的是组成图元的各个顶点的坐标数据（在3D笛卡尔坐标中即 x，y，z 坐标），这些坐标数据可以一起存到一个内存数组中，这个数据叫做顶点数组
* **顶点缓冲区**：在显存中专门分配一块显存来存储这个顶点数组，这个显存就称为顶点缓冲区
* **顶点着色器**
* **片元着色器**

## 4.2 主流图形 API

* 手机：ios和Android都支持OpenGL ES
* 电脑：Windows支持DX和OpenGL，Linux/Mac(Unix)支持OpenGL

![OpenGL 的发展过程](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906131122.jpg)

OpenGL 的发展过程中，从 1.0 开始有一个分支，一个是 OpenGL ES 1.1 ，一个是 OpenGL 2.0，最后都是 OpenGL ES 2.0
在 2.0 中都是增加了一些片元着色器，替代了一些原先的方法

20 世纪 90 年代 $\longrightarrow$ OpenGL 开放
2000 年 $\longrightarrow$ OpenGL ES 开放，直到现在的年代，OpenGL ES 已经到了 3.2 版本
2005 年 $\longrightarrow$ OpenGL SC  开放
2008 年 $\longrightarrow$ 开放基层更高效计算的 OpenCL
2014 年 $\longrightarrow$ 开放 SPIR
2015 年 $\longrightarrow$ Vulkan 开放，更加高效的 GPU 使用效率

![OpenGL 发展史](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906131935.jpg)


### OpenGL ES

#### 相同点

相比于 OpenGL ES 1.x 系列的固定功能管线，OpenGL ES 2.0 和 OpenGL ES 3.0 都是可编程图形管线。开发者可以自己编写图形管线中的 顶点着色器 和 片段着色器 两个阶段的代码。

![OpenGL ES 相同点](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240906204602.jpg)

**OpenGL ES 渲染流程**
* 2.0 版本：
首先是模型准备，然后由顶点着色器去编辑，然后把这些点面进行图元重组，然后进行光栅化，然后经过片元着色器的编写，最后通过三种测试，最后输出到 Frame Buffer 中

* 3.1 版本：
新拿到这些 Buffer 缓存，然后传到顶点池，然后传给顶点着色器，然后顶点着色器进行分布 Transform 的 Feedback，进行一个返回，让我们去了解一些数据给下一阶段是使用，下一阶段拿到这些数据使用，之后要去进行光栅化，光栅化之后就是片元着色器的计算，之后进行逐片元渲染，然后输入到 Frame Buffer 中

#### 不同点

1. 兼容性：
OpenGL ES 3.0 是向后兼容 OpenGL ES 2.0的。也就是说使用 2.0 编写的应用程序可以在 3.0 中继续使用的

2. 新特性：
采用阴影贴图，体渲染（volume rendering），基于 GPU 的例子动画，几何形状实例化
纹理压缩和伽马校正等技术的重要功能在 2.0 都不具备。3.0 将这些功能引入，同时继续适应嵌入系统的局限性。

3. 渲染管线：
3.0 中移除了 Alpha 测试 和 逻辑操作（LogincOp）两部分，这两部分存在于 OpenGL ES 2.0 和 OpenGL ES 1.x 中
移除 Alpha 测试是因为片元着色器可能抛弃片段，因此 Alpha 测试可以在片段着色器 中进行，移除 逻辑操作（LogicOp）是因为它很少被使用

4. 着色器脚本编写：
着色器脚本的辨析发生了比较大的变化，其中几点为：
    1. 版本声明
    必须在着色器脚本中使用 `#version 300 es` 声明为指定使用 OpenGL ES 3.0 版本
    而不添加脚本声明或者使用 `#version 100 es` 声名版本则指定使用 OpenGL ES 2.0 
    
    2. 输入输出
    3.0 中新增了 `in ，out，inout` 关键字，用来取代 `attribute` 和 `varying` 关键字。同时 `gl_FragColor` 和 `gl_FragData` 也删除了，片段着色器可以使用 `out` 声明字段输出

    3. 变量赋值
    3.0 中可以直接使用 layout 对指定位置的变量赋值。例如：
    ```
    #shader 脚本
    layout(location = 1 ) uniform float a;
    ```
    代码中，直接写上对应的 layout 的值就可以赋值
    `GLES30.glUniformlf(1,1f);`
    而 2.0 中必须使用如下形式赋值
    `GLES20.glUniformlf(GLES20.glGetAttribLocation(program,"a"),1f)`

### OpenGL ES 3.0 新功能

#### 1. 纹理
1. sRGB 纹理和帧缓冲区——允许应用程序执行伽马校正渲染。纹理可以保存在经过伽马校正的 sRGB 空间，在着色器中读取时反校正到线性空间，然后在输出到帧缓冲区时转换回 sRGB 伽马校正空间。通过在线性空间中正确地进行照明和其它计算，可能得到更高的视觉保真度。
2. 2D 纹理数组——保存一组 2D 纹理的纹理目标。例如这些数组可以用于执行纹理动画。在 2D 纹理数组出现之前，这种动画一般通过在单个 2D 纹理中平铺动画帧并修改纹理坐标改变动画帧来实现。有了 2D 纹理数组，动画的每个帧可以在数组的一个 2D 切片中指定。
3. 3D 纹理。一些 OpenGL ES 2.0 实现通过扩展支持 3D 纹理，而 OpenGL ES 3.0 将此作为强制的功能。
4. 深度纹理和阴影比较――启用存储在纹理中的深度缓冲区。深度纹理的最常见用途是渲染阴影，这时深度缓冲区从光源的角度渲染，然后用于在渲染场景时比较，以确定片段是否在阴影中。除了深度纹理外，OpenGL ES 3.0 可以在读取时比较深度纹理，从而在深度纹理上完成双线性过滤。
5. 无缝立方图。以往立方图渲染可能在立方图各面之间的边界产生伪像。在 OpenGL ES 3.0 中，立方图可以进行采样如过滤来使用相邻面的数据并删除接缝处的伪像。
6. 浮点纹理。OpenGL ES 3.0 扩展了支持的纹理格式。支持并可以过滤半浮点纹理(16位)，也支持全浮点纹理(32位)，但不能过滤。
7. ETC2 / EAC 纹理压缩。OpenGL ES 3.0 中强制支持 ETC2 / EAC。ETC2 / EAC 的格式为 RGB888
RGBA8888和单通道及双通道有符号/无符号
纹理数据。纹理压缩的好处包括更好的性能以及减少GPU内存占用。
8. 整数纹理。OpenGL ES 3.0 引入了渲染和读取保存为未规范化有符号或无符号 8位、16位 和 32位 整数纹理的能力。
9. 其它纹理格式。OpenGL ES 3.0 还包含了对 11-11-10 RGB 浮点纹理、共享指数 RGB 9-9-9-5 纹理、10-10-10-2 整数纹理以及 8位 分量有符号规范化纹理的支持。
10. 非2幂次纹理（NPOT）。纹理现在可以指定为不为2的幂次尺寸。
11. 纹理细节级别（LOD）。现在可以强制使用用于确定读取哪个 Mipmap 的 LOD 参数。此外，可以强制基本和最大 Mipmap 级别。这两个功能组合起来，可以流化 Mipmap。在更大的 Mipmap 级别可用时，可以提高基本级别，LOD 值可以平滑地增加，以提供平滑的流化纹理。这一功能非常有用，例如用于通过网络连接下载纹理 Mipmap。
12. 纹理调配。引入新的纹理对象状态，允许独立控制纹理数据每个通道 (R、G、B、A) 在着色器中的映射。
13. 不可变纹理。为应用程序提供在加载数据之前指定纹理格式和大小的机制。在这样做的时候，纹理格式不可变，OpenGL ES 驱动程序可以预先执行所有一致性和内存检查。通过允许驱动程序在绘制的时候跳过一致性检查，可以改善性能。
14. 最小尺寸增大。OpenGL ES 3.0 支持远大于 OpenGL ES 2.0 的纹理资源。

#### 2. 着色器
1. 二进制程序文件。在 OpenGL ES 2.0 中可以二进制格式存储着色器，但是仍需要在运行时链接到程序。在 OpenGL ES 3.0 中，完全链接过的二进制程序文件可以保存为离线二进制格式，运行时不需要链接步骤。这有助于减少应用程序的加载时间。
2. 强制的在线编译器。在 OpenGL ES 2.0 可以选择驱动程序是否支持着色器的在线编译，意图是降低驱动程序的内存需求，但是这一功能代价很大，开发人员不得不依靠供应商专用工具来生成着色器。在 OpenGL ES 3.0 中，所有实现都有在线着色器编译器。
3. 非方矩阵。支持方阵之外的新矩阵类型，并在 API 中增加了相关的统一调用，以支持这些矩阵的加载。非方矩阵可以减少执行变换所需的指令。例如执行仿射变换时，可以使用 4x3 矩阵代替最后一行为 (0,0,0,1) 的 4x4 矩阵，从而减少执行变换所需的指令。
4. 全整数支持。支持整数（以及无符号整数）标量和向量类型以及全整数操作。有各种内建函数可以实现从整数到浮点数、从浮点数到整数的转换以及从纹理中读取整数值和向整数颜色缓冲区中输出整数值的功能。
5. 质心采样。为了避免在多重采样时产生伪像，可以用质心采样声明顶点着色器和片段着色器的输出变量
6. 平面/平滑插值程序。在 OpenGL ES 2.0 中所有插值程序均隐含地在图元之间采用线性插值。在 OpenGL ES 3.0 中插值程序可以显式声明为平面或者平滑着色。
7. 统一变量块。统一变量值可以组合为统一变量块。统一变量块可以更高效地加载，也可在多个着色器程序间共享。
8. 布局限定符。顶点着色器输入可以用布局限定符声明，以显式绑定着色器源代码中的位置，而不需要调用 API。布局限定符也可以用于片段着色器的输出，在渲染到多个渲染目标时将输出绑定到各个目标。而且，布局限定符可以用于控制统一变量块的内存布局。
9. 实例和顶点 ID。顶点索引现在可以在顶点着色器中访问，如果使用实例渲染，还可以访问实例 ID。
10. 片段深度。片段着色器可以显式控制当前片段的深度值，而不是依赖深度值的插值。
11. 新的内建函数。引入了许多新的内建函数，以支持新的纹理功能、片段导数、半浮点数据转换和矩阵及数学运算。
12. 宽松的限制。大大放松了对着色器的限制。着色器不再限于指令长度，完全支持变量为基础的循环和分支，并支持数组索引。

#### 3. 几何形状
1. 变换反馈。可以在缓冲区对象中捕捉顶点着色器的输出。这对许多在 GPU 上执行动画而不需要 CPU 干预的技术很实用，例如，粒子动画或者使用“渲染到顶点缓冲区”的物理学模拟。
2. 布尔遮挡查询。应用程序可以查询一个（或者一组）绘制调用的任何像素是否通过深度测试。这个功能可以在各种技术中使用，例如镜头眩光效果的可见性确定，以及避免在边界被遮挡的对象上进行几何形状处理的优化。
3. 实例渲染。有效地渲染包含类似几何形状但是属性（例如变化矩阵、颜色或者大小）不同的对象。这一功能在渲染大量类似对象时很有用，例如人群的渲染。
4. 图元重启。在 OpenGL ES 2.0 中为新图元使用三角形条带时，应用程序必须在索引缓冲区中插入索引，以表示退化的三角形。在 OpenGL ES 3.0 中，可以还是要特殊的索引值表示新图元的开始。这就消除了使用三角形条带时生成退化三角形的需求。
5. 新顶点格式。支持包括 10-10-10-2 有符号和无符号规范化顶点属性；8位、16位 和 32位 整数属性；以及 16位 半浮点。

#### 4. 缓冲区对象
引入了许多新的缓冲区对象，以提高为图形管线各部分指定数据的效率和灵活性。
1. 统一变量缓冲区对象。为存储/绑定大的统一变量块提供高效的方法。统一变量缓冲区对象可以减少将统一变量值绑定带着色器的性能代价，这是 OpenGL ES 2.0 应用程序中的常见瓶颈。
2. 顶点数组对象。提供绑定和在顶点数组状态之间切换的高效方法。顶点数组对象实际上是顶点数组状态的容器对象。使用它们，应用程序可以在一次 API 调用中切换顶点数组状态，而不是发出多个调用。
3. 采样器对象。将采样器状态（纹理循环模式和过滤）与纹理对象分离。这为在纹理中共享采样器状态提供了更高效的方法。
4. 同步对象。为应用程序提供检查一组操作是否在 GPU 上完成执行的机制。相关的新功能是栅栏（Fence），它为应用程序提供了通知 GPU 应该等待一组操作结束才能接受更多操作进入执行队列的方法。
5. 像素缓冲对象。使应用程序能够执行对像素操作和纹理传输操作的异步数据传输。这种优化主要是为了在 CPU 和 GPU 之间提供更快的数据传输，在传输操作期间，应用程序可以继续工作。
6. 缓冲区子界映射。使应用程序能够映射缓冲区的一个子区域，供 CPU 访问。这可以提供比传统缓冲区映射更好的性能，在传统缓冲区映射中，必须使整个缓冲区可用于客户。
7. 缓冲区对象间拷贝。提供了高效地从一个缓冲区对象向另一个缓冲区对象传输数据的机制，不需要 CPU 干预。

#### 5. 帧缓冲区
增添了许多与屏幕外渲染带帧缓冲区对象相关的新功能
1. 多重渲染目标（MRT）。允许应用程序同时渲染到多个颜色缓冲区。利用 MRT 技术，片段着色器输出多个颜色，每个用于一个相连的颜色缓冲区。MRT 用于许多高级的渲染算法，例如延迟着色。
2. 多重采样渲染缓冲区。使应用程序能够渲染到具备多重采样抗锯齿功能的屏幕外帧缓冲区。多重采样帧缓冲区不能直接绑定到纹理，但是可以用新引入的帧缓冲区块移动解析为单采样纹理。
3. 帧缓冲区失效提示。OpenGL ES 3.0 的许多实现使用基于块状渲染（TBR）的 GPU。TBR 常常在必须为了进一步渲染到帧缓冲区而毫无必要地恢复图块内容时导致很高的性能代价。帧缓冲区失效为应用程序提供了通知驱动程序不再需要帧缓冲区内容的机制。这使驱动程序能够采取优化步骤，跳过不必要的图块恢复操作。这一功能对于在许多应用程序中实现峰值性能很重要，特别是那些进行大量屏外渲染的程序。
4. 新的混合方程式。OpenGL ES 3.0 支持最大值/最小值函数作为混合方程式。



### 骁龙 Adreno 对应的 OpenGL ES 版本
Adreno 是由高通开发的 SIP 核 GPU 并用于其自家的 SoC，该核心最初作为 BitBoys（英语：BitBoys）从事 GPU 开发工作。 2006年，BitBoys 被 ATI 收购开设 Imageon 产品线。2006年 AMD 收购 ATI。2009年1月，AMD 出售 Imageon 予高通。随后，Imageon 被更名为 Adreno。
也就是我们常说的骁龙手机端 GPU 框架

这两个链接可以查看对应的手机芯片支持的OpenGL es 支持的版本：
https://zh.wikipedia.org/wiki/Adreno
https://zh.wikipedia.org/wiki/%E9%AB%98%E9%80%9A%E9%A9%8D%E9%BE%8D%E5%85%83%E4%BB%B6%E5%88%97%E8%A1%A8#Snapdragon_888


### Vulkan

Vulkan 被视作是 OpenGL 的后续产品。 它是一种多平台 API，可支持开发人员准备游戏、CAD 工具、性能基准测试等高性能图形应用。 它可在不同的操作系统（比如 Windows*、Linux* 或 Android*）上使用

是新一代的 API ，但是相对 OpenGL 来说，在复杂度和维护难度上，Vulkan 的门槛很高，虽然有更高效的计算性能，作为新兴的具有生命力的 Vulkan ，相信在以后的运用中更加广泛
