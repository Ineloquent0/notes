
![L5：光栅化1(三角形的离散化)](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/L5：光栅化1(三角形的离散化).jpg)

# 1. 光栅化（三角形的离散化）
当所有物体都处在了 $[-1, 1]^3$ 的标准立方体中，接下来要把它画在屏幕上，这一步叫光栅化。

## 1.1 准备工作

### 1.1.1 定义视锥
在做透视投影时需要将一个四棱梯压成正方体，就需要定义一个视锥。

从摄像机看向一个地方，我们把它当作近平面，宽和高是可定义的，所以宽高比就是可定义的。
* 宽高比 Aspect Ratio
* 可视角度 Field of View (FOV)（垂直角度和水平角度可以互相转换）

通过以上两点可以定义一个视锥

![定义视锥体](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902114557.jpg)
![20240902115233](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902115233.jpg)
fovY表示视野角度，同时已知近平面深度为n，远平面深度为f，宽高比为aspect


### 1.1.2 标准立方体到屏幕

**什么是屏幕？**
* 一个二维数组（数组中的每一个元素是一个像素）
* 数组大小：屏幕分辨率
* 屏幕是一个光栅成像设备

Raster == 德语的屏幕
Rasterize（光栅化） == 绘制到屏幕上
把东西画在屏幕上的过程就是光栅化的过程。

Pixel 像素（"picture element" 的缩写）
* 目前可以认为像素是一个个的小方块
* 一个像素的颜色可以用 (r, g, b) 三个值来表示

#### 屏幕空间

* 像素索引是以 (x, y) 的形式来表示，其中 x、y 都是整数
* 像素的索引从 (0, 0) 到 (width - 1, height - 1)
* 像素 (x, y) 中心点为 (x + 0.5, y + 0.5)
* 屏幕覆盖范围从 (0, 0) 到 (width, height)

<div align=center>
<image src="https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902120229.jpg" alt="屏幕空间" width="300">
</div>


#### 将标准立方体映射到屏幕空间
* 先忽略 z
* 在 xy 平面中变换 $[-1, 1]^2$ 到 [0, width] x [0, height]
* 视口变换矩阵： $M_{viewport} = \begin{pmatrix} \frac{width}{2} & 0 & 0 & \frac{width}{2} \\ 0 & \frac{height}{2} & 0 & \frac{height}{2} \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{pmatrix}$


## 1.2 光栅化

### 1.2.1 三角形

**为什么光栅化选择三角形？**
* 三角形是最基本的多边形，没有比三角形更少的多边形
* 其他的多边形都可以拆分为三角形
* 三角形必定在一个平面内
* 容易定义三角形的内外
* 三角形的三个点定义好后，三角形内任意一点可以通过线性插值来计算得到（重心坐标的插值方法）
如：定义好三个点的颜色，三角形内任意一点的颜色可以通过三个点的颜色来进行插值计算得到。

**如何将三角形转化为一个个像素？**

简单近似采样。

### 1.2.2 采样
给定一个连续的函数 $f(x)$，当 x=1 时得到 $f(1)$ 就是 1 的采样。
所以**采样就是把一个函数离散化的过程。**
只要有一个定义在屏幕空间的函数，那么我们就能算出来不同像素中心的值是多少。

这里我们通过对每一个像素进行判断，如果它的中心点在三角形内部，那么它就应该在屏幕上画出来。
```
for (int x = 0; x < xmax; ++x) 
    for (int y = 0; y < ymax; ++y) 
        image[x][y] = inside(tri, x + 0.5, y + 0.5);
```
inside 函数可以根据叉乘来判断一个点是否在三角形内部。

<div align=center>
<image src="https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902123226.jpg" alt="三角形采样" width="300">
</div>

**优化**

遍历所有像素开销太大，我们知道三角形的三个顶点的坐标，有了 $X_{min}, X_{max}, Y_{min}, Y_{max}$ 就可以得到蓝色区域，我们叫它包围盒。

<center>
<image src="https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902124030.jpg" alt="包围盒" width="300">
<image src="https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902125313.jpg" alt="采样结果" width="300">
</center>

采样完成后，因为每个像素都是最小单位，像素内的颜色一样，所以我们会得到右图所示的结果。

这看起来和初始三角形差别很大，有一个个明显的锯齿（Jaggies/Aliasing）。接下来我们会学习图形学中的重大技术：反走样（Anti-Aliasing）/抗锯齿。

