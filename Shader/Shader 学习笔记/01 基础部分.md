Unity Shader 入门精要部分笔记记得比较详细，这里的笔记就简单记一下重点部分，就当复习一下。

# 1. 渲染流水线

![渲染流水线流程](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240830212340.jpg)

整体流程：应用阶段 -> 几何阶段 -> 光栅化阶段 -> 逐片元操作 -> 后处理

1. **应用阶段**：粗粒度剔除，进行渲染设置，准备基本数据，输出到几何阶段
    1. **准备场景数据**
        * 场景物体数据
            * 物体变换数据：位置、旋转、缩放等
            * 物体网格数据：顶点位置、UV贴图等
        * 相机数据
            * 位置、方向
            * 远近裁剪平面
            * 正交/透视（FOV）
            * 视口比例/尺寸等
        * 光源及阴影数据
            * 光源类型：点光源、平行光源、聚光灯等
            * 位置、方向、角度等其他参数
            * 设置阴影：是否需要阴影、阴影参数（对应光源序号、阴影强度、级联参数、深度偏移、近平面偏移等）
            * 逐光源绘制阴影贴图：近平面偏移、逐级联（计算当前光源+级联对应的观察矩阵、投影矩阵、以及对应到阴影贴图里的视口区域，绘制到阴影贴图）
        * 其他全局数据
    2. **加速算法，粗粒度剔除**
        * 碰撞检测
        * 加速算法
        * 遮挡剔除
            * 可见光裁剪
            * 可见场景物体裁剪：八叉树、BSP树、K-D树、BVH
        * 其他算法
    3. **设置渲染状态，准备渲染参数**
        * 绘制设置
            * 合批方式
        * 绘制顺序
            * 相对相机的距离
            * 材质渲染队列（Render Queue）
            * UICanvas
            * 其他方式等
        * 渲染目标
            * FrameBuffer
            * RenderTexture
        * 渲染模式
            * 前向渲染（Forward Rendering）
            * 延迟渲染（Deferred Rendering）
    4. **调用 DrawCall ，输出渲染图元到显存**
        * 顶点数据：位置、法线、UV、颜色、其他顶点数据
        * 其他数据：MVP变换矩阵、纹理贴图、其他数据
2. **几何阶段**：顶点着色器，曲面细分，几何着色器，顶点裁剪，屏幕映射
    1. **顶点着色（Vertex Shading）**
        * **视图变换（MVP变换）**：模型空间 $\stackrel{模型变换}{\longrightarrow}$ 世界空间 $\stackrel{视图变换}{\longrightarrow}$ 观察空间 $\stackrel{投影变换}{\longrightarrow}$ 裁剪空间
        * **顶点着色**：计算逐顶点光照等等
    2. **可选顶点处理**
        * **曲面细分（可选）**：利用顶点着色器输出的顶点，按照一定的规则和算法，生成更多的顶点，将现有的网格和图元细分
        * **几何着色器（可选）**：基于图元的操作，通过给定的图元生成更多的图元
    3. **投影（Projection）**：对于顶点在裁剪空间的位置 xyzw，对它进行一个透视除法，把 xyz 除以 w 来完成投影操作。这样就从投影坐标系转换到标准设备坐标系（NDC）
        * 正交：w 始终为1，所以投影到屏幕上时，不论远近 xyz 不变
        * 透视：w 近处较小，远处较大，所以投影到平面上会呈现出近大远小的效果
    4. **裁剪（Clipping）**：对于 NDC 下的顶点位置，xyz 不在 [-1, 1] 范围内的，就是在裁剪空间以外的，会舍弃掉。图元部分在裁剪空间外的，会生成两个额外的顶点补全图元
        * CVV（Canonical View Volume）
        * 正面或背面剔除（可配置）
    5. **屏幕映射（Screen Mapping）**：将标准坐标系下的顶点坐标映射到屏幕坐标系下
        * 从连续到离散
        * 坐标系差异（OpenGL/D3D）
3. **光栅化阶段**：三角形（点/线）设置，三角形（点/线）遍历，片段着色器
    1. **三角形设置（Triangle Setup）**：计算图元的边界信息
    2. **三角形遍历（Triangle Traversal）**：寻找被三角形网格所覆盖的所有像素，然后使用三角形顶点对覆盖像素进行线性插值，得到对应的片元数据
    3. **抗锯齿（Anti-Aliasing）**
        * SSAA：渲染到一个分辨率放大 n 倍的 buffer，对放大 n 倍的 buffer 下采样
        * MSAA：对 SSAA 的优化，对每个像素设置多个子采样点，并进行覆盖测试和遮挡测试，保存信息在最后逐片元进行混合
        * FXAA/TXAA：后处理技术，不在这个渲染阶段
4. **逐片元操作**：裁剪测试、透明度测试、深度测试、模板测试，混合
    1. **片元着色（Fragment Shading）**：根据顶点颜色进行插值
    2. **颜色混合（Color Blending）**
        * Alpha Test：透明度小于透明度阈值的片元将被舍弃
        * Depth Buffer Test：将片元深度值和深度缓冲区的深度值进行比较，通过测试的则保留（可自行决定是否更新深度缓冲区）
        * Stencil Test：模板测试，比较模板值，通过模板测试的片元将被保留（可自行决定是否更新模板缓冲区）
        * Blending：颜色混合
    3. **目标缓冲区（FrameBuffer）**
        * FrameBuffer
        * RenderTexture
5. **后处理**：对最后输出的缓冲区/渲染贴图进行处理。


--------------------------------------------------------------------


# 2. 数学基础

可以参考另一篇笔记： [Games101 笔记 - 数学基础部分](https://github.com/Ineloquent0/notes/blob/main/Computer%20Graphics/01%20%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80.md)


## 2.1 向量运算

### 认识向量

**向量的定义：**
* 向量是有大小和方向的有向线段
* 没有位置只有大小和方向
* 向量的箭头是向量的结束，尾是向量的开始
* 向量描述的位移能够被认为是与轴平行的位移序列
* 向量表示：三维 $(a_x, a_y, a_z)$ ，二维 $(a_x, a_y)$

**向量与标量**
* 向量：有大小和方向的有向线段
* 标量：只有大小，没有方向的量

**向量与点**
* 向量和点数学形式上相等，但几何意义完全不同。
* 向量：无位置，有实际大小和方向。
* 点：有位置，没有实际大小或方向。
* 联系：任何一个点都可以看做是从原点出发的向量。

**零向量**
* 零向量是唯一大小为零的向量
* 零向量是唯一一个没有方向的量
* 零向量不是一个点，因为没有定义某个位置
* 零向量表示的是没有位移，就像零标量表示的是没有数量一样


### 向量的计算

**标量与向量的运算**
* 没有加减
* 乘法：将每个分量都与标量相乘（例：$-2(2, -5) = (-4, 10)$）
* 除法：等同于乘以标量的倒数（例：$(6, -2, -4)/2 = (3, -1, -2)$）
* 乘除的几何意义：以标量的大小缩放向量的长度，负值则方向相反（将向量缩放至 k 个标量单位）

**向量的模长**： $\|v\| = \sqrt{v_x^2 + v_y^2 + v_z^2}$

**标准化向量（单位向量）**： 
* 大小为 1 的向量，用于只需要知道方向，不关心大小的向量。例如：法线
* 运算法则：将向量除以它的模长： $\hat{v} = \frac{v}{\|v\|}, v \neq 0$

**向量与向量的运算**
* 加法：对应位置相加（例： $(1, -4) + (7, 5) = (8, 1)$ ）
* 减法：对应位置相减（例： $(-3, 6) - (-4, 3) = (1, 3)$ ）
* 点乘：
    * 公式： $(a_x, a_y, a_z) \cdot (b_x, b_y, b_z) = a_x b_x + a_y b_y + a_z b_z$
    * 几何意义：
        * 点乘结果描述了两个向量的相似程度，点乘结果越大，夹角角度越小，两个向量越接近。 $\vec{a} \cdot \vec{b} = \| \vec{a} \| \| \vec{b} \| \cos \theta$
        * 用于计算投影
    * 满足交换律： $\vec{a} \cdot \vec{b} = \vec{b} \cdot \vec{a}$
* 叉乘：
    * 仅用于3D向量： $(a_x, a_y, a_z) \times (b_x, b_y, b_z) = (a_y b_z - a_z b_y, a_z b_x - a_x b_z, a_x b_y - a_y b_x)$
    * 几何意义：
        * 叉乘得到的向量垂直于原来的两个向量。
        * 用于判断点是否在三角形内部。
    * 不满足交换律，满足逆交换律： $\vec{a} \times \vec{b} = -(\vec{b} \times \vec{a})$
    * 叉积的大小与方向判断： $\|\vec{a} \times \vec{b}\| = \|\vec{a}\| \|\vec{b}\| \sin \theta$

**计算两点间距离：距离公式**
* 3D 距离公式： 距离 $(a, b) = \|b-a\| = \sqrt{(b_x-a_x)^2 + (b_y-a_y)^2 + (b_z-a_z)^2}$

**向量投影**
$\vec{b}$ 在 $\vec{a}$ 上的投影为： $\vec{b}_\perp = \frac{\vec{a} \cdot \vec{b}}{\|a\|^2} \hat{a}$

**兰伯特光照模型**
* 兰伯特光照模型是目前最简单通用的模拟漫发射的光照模型
* 使光照方向的反方向为 L 向量，法线方向为 N 向量，则有：
    * L 与 N 方向相同，则 Normal · Light = 1（纯亮）
    * L 与 N 方向相反，则 Normal · Light = -1（纯黑）
    * L 与 N 方向垂直，则 Normal · Light = 0（纯黑）



## 2.2 矩阵运算

### 矩阵的概念

#### **线性方程**
一次方程，没有 sin、cos 这些
* 可加性： $f(x_1 + x_2) = f(x_1) + f(x_2)$
* 比例性： $f(kx)= k f(x)$

**线性空间**：直线变换后依然是直线，并且等比或等距，坐标原点保持不变

**非线性空间**：空间扭曲，不是等距，坐标原点有位移

#### **矩阵的定义**
由 m x n 个数 $a_{ij}(i = 1,2,3...m;j=1,2,3...n)$ 排成的 m 行 n 列的数表称为 m 行 n 列矩阵，简称 m x n 矩阵。为表示这些数字是一个整体，总是加一个方括号

$$
A =
\begin{bmatrix}
a_{1,1} & a_{1,2} & \cdots &a_{1,n}\\
a_{2,1} & a_{2,2} & \cdots &a_{2,n}\\
\vdots & \vdots & \ddots & \vdots\\
a_{m,1} & a_{m,2} & \cdots &a_{m,n}\\
\end{bmatrix}
$$

#### **特殊的矩阵**
* 方阵：行数列数都相等，且都等于 n 的矩阵成为 n 阶矩阵或 n 阶方阵。例： $\begin{bmatrix}
a & b\\
c & d\\
\end{bmatrix}$
* 单位矩阵 $I$ ：n x n矩阵，从左到右的对角线上的元素是1，其余元素都是0。例： $\begin{bmatrix}
1 & 0 & 0\\
0 & 1 & 0\\
0 & 0 & 1\\
\end{bmatrix}$
* 零矩阵 $O$ ：元素都是零的矩阵。例： $\begin{bmatrix}
0 & 0 & 0\\
0 & 0 & 0\\
0 & 0 & 0\\
\end{bmatrix}$
零矩阵不相等，虽然各个元素都为0，但是元素的位数不同，所以不等
* 正交矩阵：如果一个方阵 A 和 它的转置矩阵的乘积是单位矩阵的话，我们就说这个矩阵是正交的： $A^T A = A A^T = I$ 


### 矩阵的运算

#### **矩阵加减**
* 加法：对应位置相加，只有同型矩阵（同行同列）才能相加
    * 交换律： A + B = B + A
    * 结合律： (A + B) + C = A + (B + C)
* 减法： A - B = A + (-B)
* 几何意义：对单位向量的一个变换


#### **矩阵乘法**

**常数与矩阵的乘法**：
* 矩阵与常数相乘：矩阵中每个元素乘以常数
* 几何意义：对空间的缩放

$$
kA = Ak =
\begin{bmatrix}
ka_{1,1} & ka_{1,2} & \cdots & ka_{1,n}\\
ka_{2,1} & ka_{2,2} & \cdots & ka_{2,n}\\
\vdots & \vdots & \ddots & \vdots\\
ka_{m,1} & ka_{m,2} & \cdots & ka_{m,n}\\
\end{bmatrix}
$$


**矩阵与矩阵之间的乘法**：

* 不是所有矩阵都能相乘，矩阵相乘需要满足一定的合法性
* m * n 的矩阵只能与 n * p 的矩阵相乘（第一个矩阵的列数等于第二个矩阵的行数），得到的矩阵大小为 m * p
* 得到的结果的第 i 行第 j 列的元素是：第一个矩阵第 i 行的元素与第二个矩阵第 j 列的元素的点乘结果
* 几何意义：进行矩阵变换，更改单位向量（转换到新的坐标系）
* 不满足交换律，矩阵的相乘是有顺序的，是从右向左乘的

例：

$$
\begin{bmatrix}
2 & 1\\
0 & 3\\
5 & 4\\
\end{bmatrix} *
\begin{bmatrix}
7 & 6\\
8 & 9\\
\end{bmatrix} =
\begin{bmatrix}
2*7+1*8 & 2*6+1*9\\
0*7+3*8 & 0*6+3*9\\
5*7+4*8 & 5*6+4*9\\
\end{bmatrix} =
\begin{bmatrix}
22 & 21\\
24 & 27\\
67 & 66\\
\end{bmatrix}
$$


#### **常见的矩阵**

* 纵向拉伸矩阵： $\begin{bmatrix} 1 & 0 \\ 0 & k \end{bmatrix}$
* 斜切矩阵： $\begin{bmatrix} 1 & k \\ 0 & 1 \end{bmatrix}$
* 基于 y = x 镜面对称： $\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$
* 缩放矩阵： $\begin{bmatrix} x & 0 \\ 0 & y \end{bmatrix}$
* 旋转矩阵： $\begin{bmatrix} \cos \theta & -\sin \theta \\ \sin \theta & \cos \theta \end{bmatrix}$
* 位移矩阵： $\begin{bmatrix} 1 & 0 & x \\ 0 & 1 & y \\ 0 & 0 & 1 \end{bmatrix}$
位移矩阵不是线性变换，是仿射变换。

#### **三维空间中的坐标变换**

缩放（Scale）： 

$$
S_{(s_x, s_y, s_z)} = 
\begin{bmatrix} 
s_x & 0 & 0 & 0 \\ 
0 & s_y & 0 & 0 \\ 
0 & 0 & s_z & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$


移动（Translation）：

$$ 
T_{(t_x, t_y, t_z)} = 
\begin{bmatrix}
1 & 0 & 0 & t_x \\ 
0 & 1 & 0 & t_y \\ 
0 & 0 & 1 & t_z \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$


绕x、y、z轴旋转：

$$
R_{x}(\theta) = 
\begin{bmatrix}
1 & 0 & 0 & 0 \\ 
0 & \cos\theta & -\sin\theta & 0 \\ 
0 & \sin\theta & \cos\theta & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$

$$
R_{y}(\theta) = 
\begin{bmatrix}
\cos\theta & 0 & \sin\theta & 0 \\ 
0 & 1 & 0 & 0 \\ 
-\sin\theta & 0 & \cos\theta & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$

$$
R_{z}(\theta) = 
\begin{bmatrix}
\cos\theta & -\sin\theta & 0 & 0 \\ 
\sin\theta & \cos\theta & 0 & 0 \\ 
0 & 0 & 1 & 0 \\ 
0 & 0 & 0 & 1 
\end{bmatrix}
$$


#### **矩阵的转置**
矩阵的转置就是把矩阵的行列互换，记作 $A^T$ 

矩阵的转置有以下性质：
$(A^T)^T =A$
$(AB)^T = B^TA^T$
$(A+B)^T=A^T + B^T$

#### **逆矩阵**
矩阵与它的逆矩阵相乘，得到单位矩阵，常用作矩阵变换后再次矩阵变换回原来的的初始位置

![逆矩阵](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240901185910.jpg)

$$
I = A^{-1}A = AA^{-1}
$$

**逆矩阵的运算规律**
* 逆矩阵的逆矩阵就是原矩阵本身，假设矩阵A是可逆的 $（A^{-1}）^{-1} = A$
* 若A可逆，数 λ≠0，则 λA 可逆 $（λA）^{-1} = \frac{1}{λ}A^{-1}$
* 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵 $（AB）^{-1} = B^{-1}A^{-1}$
这个性质可以扩散到更多矩阵的连乘 $(ABCD)^{-1} = D^{-1}C^{-1}B^{-1}A^{-1}$
* 转置矩阵的逆矩阵是逆矩阵的转置 $（A^T）^{-1} = (A^{-1})^{T}$

## 2.3 MVP矩阵

MVP：模型（Model）、视图（View）、投影（Projection）

模型空间（Local Space） $\stackrel{模型变换(M)}{\longrightarrow}$ 世界空间（World Space） $\stackrel{视图变换(V)}{\longrightarrow}$ 观察空间（View Space） $\stackrel{投影变换(P)} \longrightarrow$ 屏幕空间（Screen Space）

#### M 矩阵

模型变换矩阵，将物体从局部坐标系转换到世界坐标系
* 模型空间：以自身中心为原点的空间坐标系
* 世界空间：以世界中心为原点的空间坐标系

$$
M =
\begin{bmatrix}
1 & 0 & 0 & tx\\
0 & 1 & 0 & ty\\
0 & 0 & 1 & tz\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
cos\theta & 0 & sin\theta & 0\\
0 & 1 & 0 & 0\\
-sin\theta & 0 & cos\theta & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
kx & 0 & 0 & 0\\
0 & ky & 0 & 0\\
0 & 0 & kz & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

#### V 矩阵

视图变换矩阵，将物体从世界坐标系转换到观察坐标系
* 观察空间：以摄像机位置为原点的空间坐标系

$$
V =
\begin{bmatrix}
1 & 0 & 0 & 0\\
0 & cos \theta & -sin \theta & 0\\
0 & sin \theta & cos \theta & 0\\
0 & 0 & 0 & 1\\
\end{bmatrix}
\begin{bmatrix}
1 & 0 & 0 & tx\\
0 & 1 & 0 & ty\\
0 & 0 & 1 & tz\\
0 & 0 & 0 & 1\\
\end{bmatrix}
$$

#### P 矩阵

投影变换矩阵，将物体从观察坐标系转换到屏幕坐标系
* 屏幕空间：以屏幕左下角为原点的空间坐标系

1. 不是真的投影，为投影做准备
2. 目的：判断顶点是否在可见范围内。
3. P矩阵：对 x,y,z 分量进行缩放，用 w 分量做范围值。如果 x,y,z 都在 w 范围内，那么该点在裁剪空间内。


------------------------------------------------------------------


# 3. 纹理基础

## 3.1 纹理的概念
纹理是一张图片，是一种可供着色器读写的结构化存储形式

牺牲几何细节，提升建模工作量、存储空间、读取速度。

**纹理管线**

模型空间位置 => 投影函数 => 纹理映射 => 纹理坐标 => 通讯函数 => 新纹理坐标 => 纹理采样（避免依赖纹理读取） => 纹理值

> * **投影函数**：获取我们要渲染的位置，将它从模型空间投影到纹理空间中，转化为 UV 坐标（投影指的是纹理投影，不同于摄像机投影，常规情况下投影函数通常会在 “展 UV” 的阶段中使用，将投影的结果存储在顶点数据中。所以通常我们是直接使用存储在模型顶点数据中的投影的结果）
> * **通讯函数**：将 UV 坐标进行一个灵活的扩展，实现平移缩放旋转或者是控制图像的应用方式等等，得到一个新的纹理坐标，用这个纹理坐标就可以去获取纹理的值了（纹理采样）
> * 着色器中的纹理通常会以 Sampler Variable（采样器变量）的形式存在，即我们经常看见的 sampler，这是一种 Uniform 类型的变量，在处理不同片元时这个变量是不变的。
> * **依赖纹理读取**：当我们使用 tex2D 或类似方式去访问纹理时，只要 fragment shader 不是直接用 vertex shader 传过来的数据，而是需要计算的数据，那么他就会产生一个叫做依赖纹理读取的东西，哪怕这个处理只是简单的交换 UV 的两个坐标。**只要不是顶点着色器传过来的纹理采样数据，在片元着色器需要计算纹理偏移，哪怕是只进行了一些计算，也会影响性能的表现。**

![纹理管线](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902093018.jpg)



### 纹理采样设置

#### Wrap Mode
决定 UV 值在 [0,1] 以外的表现
OpenGL -- "包装模式"(Wrapping Model)
DirectX  -- "纹理寻址模式"(Texture Addressing Mode)

![Wrap Mode](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902092351.jpg)

#### Filter Model
当纹理由于变化而产生拉伸时，要采用哪种滤波来调整它自身的表现

![Filter Model](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902094436.jpg)

* **最邻近**：读取它最近的纹素（效果类似像素化），消耗最低
* **双线性**：找到相邻的四个点，进行线性插值，来得到这个像素的混合值
* **立方体卷积插值**（也叫双三次插值）：不仅考虑到周围四个相邻像素点的影响，还考虑到它们变化率的影响，共采样16个点，根据它们与中心像素的距离，来带入到不一样的公式区运算它们对这个位置的影响值。效果最好，消耗最大。

![立方体卷积](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902095911.jpg)

* **Lanczos 插值**： Lanczos 核函数来计算插值后的像素值。Lanczos 核函数是一种低通滤波器，可以消除缩放过程中产生的混叠现象。它取了 8x8 个像素来计算，代价很高（感兴趣可以自行了解，这里不做过多介绍）
* **Quilez 的光滑曲线插值**：在立方卷积插值与双线性插值的一个折中效果，画面表现效果要比双线性插值好，比立方卷积插值差，消耗也比立方体卷积小。

![Quilez 的光滑曲线插值](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902102231.jpg)
![光滑曲线插值](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902102307.jpg)

效果对比：

![效果对比](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902102531.jpg)


#### 纹理缩小的情况
纹理缩小时，会出现几个纹理覆盖一个像素的情况，会出现颜色丢失与闪烁。
常见的过滤方法有最邻近和双线性插值，原理与放大的时候一样。

#### Mipmap
Mipmap：预处理纹理并创建数据结构，有助于实时工作时快速计算一组纹素对一个像素的近似值，内存比原本多了 1/3

![Mipmap](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902110448.jpg)

**如何选择正确的 level**
使用四个像素单元格所形成的一个四边形的最长边来近似这个像素覆盖的范围，在 GPU 中并不是一个像素一个像素的去渲染执行，而是分成 2x2 一组并行进行处理，这样做的原因是用来计算 ddx  ddy，以及用来计算法线

![Mipmap 如何选择正确的 level](https://raw.githubusercontent.com/Ineloquent0/notes/main/images/20240902110546.jpg)

由于 mipmap 只实现正方形内的范围查找，于是会产生 overblur 的问题：屏幕像素对应材质的长方形甚至斜长的区域，在做 mipmap 时，自然会取过大的正方形，从而导致模糊的情况。










