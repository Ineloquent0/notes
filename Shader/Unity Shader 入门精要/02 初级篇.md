
# 第5章 开始 Unity Shader 学习之旅

## 5.1 本书使用的软件和环境
本书使用的Unity版本是Unity 5.2.1免费版。

本书工程编写的系统环境是Mac OS X 10.9.5。如果读者使用的是其他系统，绝大部分情况也不会有任何问题。但有时会由于图像编程接口的种类和版本不同而有一些差别，这是因为Mac使用的图像编程接口是基于OpenGL的，而其他平台如Windows，可能使用的是DirectX。例如，在OpenGL中，渲染纹理（Render Texture）的(0, 0)点是在左下角，而在DirectX中，(0, 0)点是在左上角。



## 5.2 一个最简单的顶点/片元着色器

### 5.2.1 顶点/片元着色器的基本结构

我们在 3.3 节已经看到了 Unity Shader 的基本结构。它包含了Shader、Properties、SubShader、Fallback 等语义块。顶点/片元着色器的结构与之大体类似，它的结构如下:

```
Shader "MyShaderName" {

    Properties {
        // 属性
    }

    SubShader {
        // 针对显卡 A 的 SubShader
        Pass {
            // 设置渲染状态和标签

            // 开始 Cg 代码片段
            CGPROGRAM
            // 该代码片段的编译指令，例如：
            #pragma vertex vert
            #pragma fragment frag
            
            // Cg 代码写在这里

            ENDCG

            // 其他设置

        }
        //其他需要的 Pass
    }
    SubShader {
        // 针对显卡 B 的 SubShader
    }

    // 上述 SubShader 都失败后用于回调的 Unity Shader
    Fallback "VertexLit"
}
```

其中，最重要的部分是Pass语义块，我们绝大部分的代码都是写在这个语义块里面的。下面我们就来创建一个最简单的顶点/片元着色器：
1. 新建一个场景，把它命名为Scene_5_2。去掉天空盒，在菜单栏中选择 Window > Lighting > Skybox 把该项设置为None。(Unity 2023 是 Window > Rendering > Lighting > Environment > Skybox Material)
2. 新建一个 Unity Shader，把它命名为 Chapter5-SimpleShader。
3. 新建一个材质，把它命名为 SimpleShaderMat。把第2步中新建的 Unity Shader 赋给它。
4. 新建一个球体，拖曳它的位置以便在Game视图中可以合适地显示出来。把第3步中新建的材质拖曳给它。
5. 双击打开第2步中创建的 Unity Shader。删除里面的所有代码，把下面的代码粘贴进去:

```
Shader "Unity Shaders Book/Chapter 5/Simple Shader"{ 
    // Properties 语义并不是必需的

    SubShader { 
        Pass{
            CGPROGRAM

            // 告诉 Unity 哪个函数是顶点着色器，哪个函数是片元着色器
            // #pragma vertex name
            // #pragma fragment name
            #pragma vertex vert
            #pragma fragment frag

            // 顶点着色器函数
            float4 vert(float4 v : POSITION): SV_POSITION { 
                // 把顶点坐标从模型空间转换到裁剪空间
                // return mul (UNITY_MATRIX_MVP, v);
                return UnityObjectToClipPos (v);
            }

            // 片元着色器函数
            fixed4 frag(): SV_Target { 
                return fixed4(1.0, 1.0, 1.0, 1.0);
            }

            ENDCG
        }
    }
}
```

保存并返回 Unity 查看结果：

![图5.2 用一个最简单的顶点/片元着色器得到一个白色的球](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/5.2.jpg)


我们具体看一下 vert 函数的定义：

```
float4 vert(float4 v : POSITION): SV_POSITION { 
    // return mul (UNITY_MATRIX_MVP, v);
    return UnityObjectToClipPos (v);
}
```

POSITION 和 SV_POSITION 是 Cg/HLSL 中的语义，这些语义将告诉系统需要哪些输入值，以及输出的是什么。
在这里 POSITION 将告诉 Unity 把模型的顶点坐标填充到输入参数 v 中，SV_POSITION 将告诉 Unity 顶点着色器的输出是裁剪空间中的顶点坐标。


然后，我们再来看一下 frag 函数：

```
// 片元着色器函数
fixed4 frag(): SV_Target { 
    return fixed4(1.0, 1.0, 1.0, 1.0);
}
```

在本例中，frag 函数没有任何输入。它的输出是一个 fixed4 类型的变量，并且使用了 SV_Target 语义进行限定。SV_Targer 也是 HLSL 中的一个系统语义，它等同于告诉渲染器，把用户的输出颜色存储到一个渲染目标(render target)中，这里将输出到默认的帧缓存中。片元着色器中的代码很简单，返回了一个表示白色的 fixed4 类型的变量。片元着色器输出的颜色的每个分量范围在[0, 1]，其中(0,0,0)表示黑色，而(1,1,1)表示白色。


### 5.2.2 模型数据从哪里来？

如果我们想要得到更多模型数据，我们就需要定义一个结构体作为输入参数。

```
Shader "Unity Shaders Book/Chapter 5/Simple Shader"{ 
    SubShader { 
        Pass{
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            // 使用一个结构体来定义顶点着色器的输入
            struct a2v {
                // POSITION 语义告诉Unity，用模型空间的顶点坐标填充 vertex 变量
                float4 vertex : POSITION;
                // NORMAL 语义告诉Unity，用模型空间的法线方向填充 normal 变量
                float3 normal : NORMAL;
                // TEXCOORD0 语义告诉Unity，用模型的第一套纹理坐标填充 texcoord 变量
                float4 texcoord : TEXCOORD0;
            };

            float4 vert(a2v v): SV_POSITION { 
                // 使用 v.vertex 来访问模型空间的顶点坐标
                // return mul(UNITY_MATRIX_MVP, v.vertex);
                return UnityObjectToClipPos (v.vertex);
            }

            fixed4 frag(): SV_Target { 
                return fixed4(1.0, 1.0, 1.0, 1.0);
            }

            ENDCG
        }
    }
}
```

对于顶点着色器的输入，Unity 支持的语义有：
* POSITION: 顶点位置
* TANGENT：切线
* NORMAL：法线
* TEXCOORD0：纹理坐标
* TEXCOORD1
* TEXCOORD2
* TEXCOORD3
* COLOR：顶点颜色
等等...


### 5.2.3 顶点着色器和片元着色器之间如何通信

我们希望从顶点着色器输出一些数据到片元着色器，这就涉及到顶点着色器和片元着色器之间的通信。
为此，我们需要再定义一个新的结构体：

```
Shader "Unity Shaders Book/Chapter 5/Simple Shader"{ 
    SubShader { 
        Pass{
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            struct a2v {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f {
                // SV_POSITION 语义告诉 Unity，pos 里包含了顶点在裁剪空间中的位置
                float4 pos : SV_POSITION;
                // COLOR0 语义可以用于存储颜色信息
                fixed3 color : COLOR0;
            };

            v2f vert(a2v v) { 
                // 声明输出结构
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                // v.normal 包含了顶点的法线方向，其分量范围在[-1, 1]
                // 下面代码把分量范围映射到了 [0, 1]
                // 存储到 o.color 中传递给片元着色器
                o.color =  v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);
                return o;
            }

            fixed4 frag(v2f i): SV_Target { 
                // 将插值后的 i.color 显示到屏幕上
                return fixed4(i.color, 1.0);
            }

            ENDCG
        }
    }
}
```


### 5.2.4 如何使用属性

我们可以定义一些属性，让用户可以调整着色器的一些参数。

```
Shader "Unity Shaders Book/Chapter 5/Simple Shader"{ 
    Properties { 
        // 声明一个 Color 类型的属性
        _Color ("Color Tint", Color) = (1.0, 1.0, 1.0, 1.0)
    }
    SubShader { 
        Pass{
            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            // 在 CG 代码中，我们需要定义一个与属性名称和类型都匹配的变量
            fixed4 _Color;

            struct a2v {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
                float4 texcoord : TEXCOORD0;
            };

            struct v2f {
                float4 pos : SV_POSITION;
                fixed3 color : COLOR0;
            };

            v2f vert(a2v v) {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                o.color =  v.normal * 0.5 + fixed3(0.5, 0.5, 0.5);
                return o;
            }

            fixed4 frag(v2f i): SV_Target { 
                fixed3 c = i.color;
                // 使用 _Color 属性来控制输出颜色
                c *= _Color.rgb;
                return fixed4(c, 1.0);
            }

            ENDCG
        }
    }
}
```

ShaderLab 属性类型和 Cg 变量类型的匹配关系：

| ShaderLab 属性类型 | Cg 变量类型 |
| --- | --- |
| Color, Vector | float4, half4, fixed4 |
| Range, Float | float, half, fixed |
| 2D           | sampler2D |
| 3D           | sampler3D |
| Cube         | samplerCUBE |



## 5.3 Unity 提供的内置文件和变量
为了方便开发者的编码过程，Unity 提供了很多内置文件，这些文件包含了很多提前定义的函数、变量和宏等。如果读者在学习他人编写的 Unity Shader 代码时，遇到了一些从未见过的变量、函数，而又无法找到对应的声明和定义，那么很有可能就是这些代码使用了 Unity 内置文件提供的函数和变量。

### 5.3.1 内置的包含文件
**包含文件（include file）**，是类似于C++中头文件的一种文件。在Unity中，它们的文件后缀是．cginc。在编写Shader时，我们可以使用#include指令把这些文件包含进来，这样我们就可以使用Unity为我们提供的一些非常有用的变量和帮助函数。例如：

```
CGPROGRAM
// ...
#include "UnityCG.cginc"
// ...
ENDCG
```

那么，这些文件在哪里呢?我们可以在官方网站(https://unity3d.com/cn/get-unity/download/archive)上选择下载 > 内置着色器 来直接下载这些文件（2023年：https://unity.com/cn/releases/editor/archive 上选择 See all > Other installs > Shaders）。图5.3 显示了由官网压缩包得到的文件。

![图5.3 Unity 的内置着色器](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/5.3.jpg)

我们也可以在Unity的安装目录下找到 CGIncludes文件夹，在Mac上位于：/Applications/Unity/Unity.app/Contents/CGIncludes；在Windows上位于：Unity的安装路径/Data/CGIncludes。

表5.2 Unity 中一些常用的包含文件：
 文件名 | 描述
 --- | ---
 UnityCG.cginc              | 包含了最常用的帮助函数、宏和结构体等
 UnityShaderVariables.cginc | 在编译 Unity Shader 时，会被自动包含进来。包含了许多内置的全局变量，如 UNITY_MATRIX_MVP 等
 Lighting.cginc             | 包含了各种内置的光照模型，如果编写的是 Surface Shader 的话，会自动包含进来
 HLSLSupport.cginc          | 在编译 Unity Shader 时，会被自动包含进来。声明了很多用于跨平台编译的宏和定义

表5.3 UnityCG.cginc 中一些常用的结构体
 名称 | 描述 | 包含的变量
 --- | --- | ---
 appdata_base   | 可用于顶点着色器的输入 | 顶点位置、顶点法线、第一组纹理坐标
 appdata_tan    | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、第一组纹理坐标
 appdata_full   | 可用于顶点着色器的输入 | 顶点位置、顶点切线、顶点法线、四组(或更多)纹理坐标
 appdata_img    | 可用于顶点着色器的输入 | 顶点位置、第一组纹理坐标
 v2f_img        | 可用于顶点着色器的输出 | 裁剪空间中的位置、第一组纹理坐标


表5.4 UnityCG.cginc 中一些常用的帮助函数
函数名 | 描述
--- | ---
float3 WorldSpaceViewDir (float4 v) | 输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向
float3 ObjSpaceViewDir (float4 v)   | 输入一个模型空间中的顶点位置，返回模型空间中从该点到摄像机的观察方向
float3 WorldSpaceLightDir (float4 v) | 仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化
float3 ObjSpaceLightDir (float4 v)  | 仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向、没有被归一化
float3 UnityObjectToWorldNormal (float3 norm)  | 把法线方向从模型空间转换到世界空间中
float3 UnityObjectToWorldDir (float3 dir)      | 把方向矢量从模型空间变换到世界空间中
float3 UnityWorldToObjectDir (float3 dir)      | 把方向矢量从世界空间变换到模型空间中

我们建议读者在 UnityCG.cginc 文件找到这些函数的定义，并尝试理解它们。一些函数我们完全可以自己实现，例如 UnityObjectToWorldDir 和 UnityWorldTo0bjectDir，这两个函数实际上就是对方向矢量进行了一次坐标空间变换。而UnityCGcginc文件可以帮助我们提高代码的复用率。UnityCGcginc还包含了很多宏，在后面的学习中，我们就会遇到它们。


### 5.3.2 内置的变量
Unity 提供了用于访问时间、光照、雾效和环境光等目的的变量。这些内置变量大多位于 UnityShaderVariables.cginc 中，与光照有关的内置变量还会位于 Lighting.cginc、AutoLight.cginc 等文件中。当我们在后面的学习中遇到这些变量时,再进行详细的讲解。



## 5.4 Unity 提供的 Cg/HLSL 语义

### 5.4.1 什么是语义

**语义（semantics）** 实际上就是一个赋给Shader输入和输出的字符串，这个字符串表达了这个参数的含义。通俗地讲，这些语义可以让Shader知道从哪里读取数据，并把数据输出到哪里，它们在CG/HLSL 的Shader流水线中是不可或缺的。需要注意的是，Unity 并没有支持所有的语义。

通常情况下，这些输入输出变量并不需要有特别的意义，也就是说，我们可以自行决定这些变量的用途。例如在上面的代码中，顶点着色器的输出结构体中我们用 COLOR0 语义去描述color变量。color 变量本身存储了什么，Shader 流水线并不关心。

而 Unity 为了方便对模型数据的传输，对一些语义进行了特别的含义规定。例如，在顶点着色器的输入结构体a2f用 TEXCOORD0 来描述 texcoord，Unity 会识别 TEXCOORD0 语义，以把模型的第一组纹理坐标填充到 texcoord 中。需要注意的是，即便语义的名称一样，如果出现的位置不同，含义也不同。例如，在输入结构体 a2f 中， TEXCOORD0 有特别的含义，即把模型的第一组纹理坐标存储在该变量中，而在输出结构体 v2f 中，TEXCOORD0 修饰的变量含义就可以由我们来决定。

在 DirectX 10 以后，有了一种新的语义类型，就是**系统数值语义(system-value semantics)**。
这类语义是以 SV 开头的,SV 代表的含义就是**系统数值(system-value)**。这些语义在渲染流水线中有特殊的含义。用这些语义描述的变量是不可以随便赋值的，因为流水线需要使用它们来完成特定的目的，例如渲染引擎会把用 SV_POSITION 修饰的变量经过光栅化后显示在屏幕上。

一些 Shader 会使用 POSITION 而非 SV_POSITION 来修饰顶点着色器的输出。SV_POSITION 是 DirectX 10 中引入的系统数值语义，在绝大多数平台上，它和 POSITION 语义是等价的，但在某些平台（例如索尼 PS4）上必须使用 SV_POSITION 来修饰顶点着色器的输出，否则无法让 Shader 正常工作。同样的例子还有 COLOR 和 SV_Target。因此，**为了让我们的 Shader 有更好的跨平台性，对于这些有特殊含义的变量我们最好使用以 SV 开头的语义进行修饰。**


### 5.4.2 Unity 支持的语义

表5.5 从应用阶段传递模型数据给顶点着色器时 Unity 支持的常用语义
 语义 | 描述
 --- | ---
 POSITION   | 模型空间中的顶点位置，通常是 float4 类型
 NORMAL     | 顶点法线，通常是 float3 类型
 TANGENT    | 顶点切线，通常是 float4 类型
 TEXCOORDn, 如 TEXCOORD0 、 TEXCOORD1 等 | 该顶点的纹理坐标，TEXCOORD0 表示第一组纹理坐标，依此类推。通常是 float2 或 float4 类型
 COLOR      | 顶点颜色，通常是 fixed4 或 float4 类型

其中 TEXCOORDn 中 n 的数目是和 Shader Model 有关的，例如一般在 Shader Model 2（即 Unity 默认编译到的 Shader Model 版本）和 Shader Model 3 中，n 等于 8，而在 Shader Model 4 和 Shader Model 5 中，n 等于 16 。通常情况下，一个模型的纹理坐标组数一般不超过2，即我们往往只使用 TEXCOORD0 和 TEXCOORD1。在 Unity 内置的数据结构体 appdata_full 中，它最多使用了6个坐标纹理组。


表5.6 从顶点着色器传递数据给片元着色器时 Unity 使用的常用语义
 语义 | 描述
 --- | ---
 SV_POSITION    | 裁剪空间中的顶点坐标，结构体中必须包含一个用该语义修饰的变量。等同于 DirectX 9 中的 POSITION，但最好使用 SV_POSITION
 COLORO         | 通常用于输出第一组顶点颜色，但不是必需的
 COLOR1         | 通常用于输出第二组顶点颜色，但不是必需的
 TEXCOORD0～TEXCOORD7 | 通常用于输出纹理坐标，但不是必需的

上面的语义中，除了 SV_POSITION 是有特别含义外，其他语义对变量的含义没有明确要求，也就是说，我们可以存储任意值到这些语义描述变量中。通常，如果我们需要把一些自定义的数据从顶点着色器传递给片元着色器，一般选用 TEXCOORD0 等。


表5.7 片元着色器输出时 Unity 支持的常用语义
 语义 | 描述
 --- | ---
 SV_Target     | 输出值将会存储到渲染目标（render target）中。等同于 DirectX 9 中的 COLOR，但最好使用 SV_Target



### 5.4.3 如何定义复杂的变量类型
上面提到的语义绝大部分用于描述标量或矢量类型的变量，例如 fixed2、float、float4、fixed4 等。下面的代码给出了一个使用语义来修饰不同类型变量的例子:

```
struct v2f{
    float4 pos : SV_POSITION;
    fixed3 color0 : COLOR0;
    fixed4 color1 : COLOR1;
    half value0 : TEXCOORDO;
    float2 valuel : TEXCOORD1;
};
```

一个语义可以使用的寄存器只能处理4个浮点值(float)。因此，如果我们想要定义矩阵类型，如 float3×4、float4×4 等变量就需要使用更多的空间。一种方法是，把这些变量拆分成多个变量，例如对于 float4×4 的矩阵类型，我们可以拆分成 4 个 float4 类型的变量，每个变量存储了矩阵中的一行数据。


## 5.5 程序员的烦恼：Debug

### 5.5.1 使用假彩色图像

**假彩色图像（false-color image）** 指的是用假彩色技术生成的一种图像。与假彩色图像对应的是照片这种**真彩色图像（true-color image）**。一张假彩色图像可以用于可视化一些数据，主要思想是，我们可以把需要调试的变量映射到[0,1]之间，把它们作为颜色输出到屏幕上，然后通过屏幕上显示的像素颜色来判断这个值是否正确。

作为实例，下面我们会使用假彩色图像的方式来可视化一些模型数据，如法线、切线、纹理坐标、顶点颜色，以及它们之间的运算结果等。我们使用的代码如下:

```
Shader "Unity Shaders Book/Chapter 5/False Color"
{
    SubShader
    {
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct v2f
            {
                float4 pos : SV_POSITION;
                fixed4 color : COLOR0;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;

            v2f vert (appdata_full v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);

                // 可视化法线方向
                o.color = fixed4(v.normal * 0.5 + fixed3(0.5, 0.5, 0.5), 1.0);

                // 可视化切线方向
                o.color = fixed4(v.tangent.xyz * 0.5 + fixed3(0.5, 0.5, 0.5), 1.0);

                // 可视化副切线方向
                fixed3 bitangent = cross(v.normal, v.tangent.xyz) * v.tangent.w;
                o.color = fixed4(bitangent * 0.5 + fixed3(0.5, 0.5, 0.5), 1.0);

                // 可视化第一组纹理坐标
                o.color = fixed4(v.texcoord.xy, 0.0, 1.0);

                // 可视化第二组纹理坐标
                o.color = fixed4(v.texcoord1.xy, 0.0, 1.0);

                // 可视化第一组纹理坐标的小数部分
                o.color =  frac(v.texcoord);
                if(any(saturate(v.texcoord) - v.texcoord)){
                    o.color.b = 0.5;
                }
                o.color.a = 1.0;

                // 可视化第二组纹理坐标的小数部分
                o.color =  frac(v.texcoord1);
                if(any(saturate(v.texcoord1) - v.texcoord1)){
                    o.color.b = 0.5;
                }
                o.color.a = 1.0;

                // 可视化顶点颜色
                o.color = v.color;

                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                return i.color;
            }
            ENDCG
        }
    }
}
```

在上面的代码中，我们使用了Unity内置的一个结构体——appdata_full，appdata_full 几乎包含了所有的模型数据。我们可以在 UnityCG.cginc 文件中找到它的定义：

```
struct appdata_full
{
    float4 vertex   : POSITION;
    float4 tangent  : TANGENT;
    float3 normal   : NORMAL;
    float4 texcoord : TEXCOORD0;
    float4 texcoord1 : TEXCOORD1;
    float4 texcoord2 : TEXCOORD2;
    float4 texcoord3 : TEXCOORD3;
#if defined(SHADER_API_XBOX360)
    half4 texcoord4 : TEXCOORD4;
    half4 texcoord5 : TEXCOORD5;
#endif
    fixed4 color    : COLOR;
};
```

![图5.4 使用假彩色对 Unity Shader 进行调试](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/5.4.jpg)

为了可以得到某点的颜色值，我们可以使用类似颜色拾取器的脚本得到屏幕上某点的 RGBA 值，从而推断出该点的调试信息。在本书的附带工程中，读者可以找到这样一个简单的实例脚本: Assets -> Scripts -> Chapter5 -> ColorPicker.cs。把该脚本拖曳到一个摄像机上，单击运行后，可以用鼠标单击屏幕,以得到该点的颜色值，如图 5.5 所示。

![图5.5 使用颜色拾取器来查看调试信息](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/5.5.jpg)


### 5.5.2 利用神器：Visual Studio
Visual Studio 作为 Windows 系统下的开发利器，在 Visual Studio 2012 版本中也提供了对 Unity Shader 的调试功能——Graphics Debugger。

通过 Graphics Debugger，我们不仅可以查看每个像素的最终颜色、位置等信息，还可以对顶点着色器和片元着色器进行单步调试。具体的安装和使用方法可以参见 Unity 官网文档中使用 Visual Studio 对 DirectX 11 的 Shader 进行调试一文(https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html)。
当然，本方法也有一些限制。例如，我们需要保证 Unity运行在 DirectX 11 平台上，而且 GraphicsDebugger本身存在一些bug。


### 5.5.3 最新利器：帧调试器

Unity 5 引入了新的针对渲染的调试器——**帧调试器（Frame Debugger）**。帧调试器可以用于查看渲染该帧时进行的各种渲染事件(event)，这些事件包含了 Draw Call 序列，也包括了类似清空帧缓存等操作。可以在 *Window - Frame Debugger* 菜单中打开帧调试器窗口。

帧调试器窗口大致可分为3个部分:
* 最上面的区域可以开启/关闭(单击 Enable 按钮)帧调试功能，当开启了帧调试时，通过移动窗口最上方的滑动条(或单击前进和后退按钮)，我们可以重放这些渲染事件；
* 左侧的区域显示了所有事件的树状图，在这个树状图中，每个叶子节点就是一个事件，而每个父节点的右侧显示了该节点下的事件数目我们可以从事件的名字了解这个事件的操作，例如以 Draw 开头的事件通常就是一个 Draw Call；
* 当单击了某个事件时，在右侧的窗口中就会显示出该事件的细节，例如几何图形的细节以及使用了哪个 Shader 等。

同时在 Game 视图中我们也可以看到它的效果。如果该事件是一个 DrawCall 并且对应了场景中的一个  GameObject，那么这个 GameObject 也会在 Hierarchy 视图中被高亮显示出来，图 5.7 显示了单击渲染某个对象的深度图事件的结果。

![图5.7 单击Knot的深度图渲染事件，在Game视图会显示该事件的效果，在Hierarchy视图中会高亮显示Knot对象，在帧调试器的右侧窗口会显示出该事件的细节](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/5.7.jpg)

Unity 5 提供的帧调试器实际上并没有实现一个真正的帧拾取（frame capture）的功能，而是仅仅使用停止渲染的方法来查看渲染事件的结果。例如，如果我们想要查看第4个 Draw Call 的结果，那么帧调试器就会在第4个 Draw Call 调用完毕后停止渲染。这种方法虽然简单，但得到的信息也很有限。



## 5.6 小心：渲染平台的差异
Unity的优点之一是其强大的跨平台性——写一份代码可以运行在很多平台上。绝大多数情况下，Unity为我们隐藏了这些细节，但有些时候我们需要自己处理它们。本节给出了一些常见的因为平台不同而造成的差异。

### 5.6.1 渲染纹理的坐标差异

OpenGL 和 DirectX 的屏幕空间坐标的差异：在水平方向上，两者的数值变化方向是相同的，但在竖直方向上，两者是相反的。在 OpenGL（OpenGLES 也是）中，(0，0)点对应了屏幕的左下角，而在 DirectX（Meta1 也是）中，(0，0)点对应了左上角。

![图5.8 OpenGL和DirectX使用了不同的屏幕空间坐标](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/5.8.jpg)

大多数情况下，这样的差异并不会对我们造成任何影响。但当我们要使用渲染到纹理技术，把屏幕图像渲染到一张渲染纹理中时，如果不采取行任何措施的话，就会出现纹理翻转的情况。幸运的是，Unity 在背后为我们处理了这种翻转问题——当在 DirectX 平台上使用渲染到纹理技术时，Unity 会为我们翻转屏幕图像纹理，以便在不同平台上达到一致性。

在一种特殊情况下 Unity 不会为我们进行这个翻转操作，这种情况就是我们开启了抗锯齿(在 Edit - Project Settings - Quality - Anti Aliasing 中开启)并在此时使用了渲染到纹理技术。在这种情况下，Unity 首先渲染得到屏幕图像，再由硬件进行抗锯齿处理后，得到一张渲染纹理来供我们进行后续处理。此时，在 DirectX 平台下，我们得到的输入屏幕图像并不会被 Unity 翻转，也就是说，此时对屏幕图像的采样坐标是需要符合 DirectX 平台规定的。

如果我们的屏幕特效只需要处理一张渲染图像，我们仍然不需要在意纹理的翻转问题，如果我们需要同时处理多张渲染图像（前提是开启了抗锯齿），例如需要同时处理屏幕图像和法线纹理，这些图像在竖直方向的朝向就可能是不同的（只有在DirectX这样的平台上才有这样的问题）。这种时候，我们就需要自己在顶点着色器中翻转某些渲染纹理(例如深度纹理或其他由脚本传递过来的纹理)的纵坐标，使之都符合DirectX平台的规则。例如:

```
#if UNITY_UV_STARTS_AT_TOP // 判断当前平台是否是 DirectX 类型的平台
if (_MainTex_TexelSize.y < 0)
    uv.y = 1-uv.y;
#endif
```


### 5.6.2 Shader 的语法差异

读者在 Windows 平台下编译某些在 Mac 平台下工作良好的 Shader 时，可能会看到类似下面 的报错信息：
```
incorrect number of arguments to numeric-type constructor (compiling for d3dll)
```
或者
```
output parameter 'o' not completely initialized (compiling for d3dll)
```
上面的报错都是因为DirectX 9/11对Shader的语义更加严格造成的。例如，造成第一个报错 信息的原因是，Shader中可能存在下面这样的代码：
```
// v是float4类型，但在它的构造器中我们仅提供了一个参数
float4 v = float4(0.0);
```

在 OpenGL 平台上，上面的代码是合法的，它将得到一个4个分量都是 0.0 的 float4 类型的变量。 但在 DirectX 11 平台上，我们必须提供和变量类型相匹配的参数数目。也就是说，我们应该写成： 
```
float4 v = float4(0.0, 0.0, 0.0, 0.0);
```

而对于第二个报错信息，往往是出现在表面着色器中。表面着色器的顶点函数有一个使用了 out 修饰符的参数。如果出现这样的报错信息，可能是因为我们在顶 点函数中没有对这个参数的所有成员变量都进行初始化。我们应该使用类似下面的代码来对这些 参数进行初始化：
```
void vert (inout appdata_full v, out Input o) {
    //使用Unity内置的 UNITY_INITIALIZE_OUTPUT 宏对输出结构体o进行初始化
    UNITY_INITIALIZE_OUTPUT(Input o);
    // ...
}
```

DirectX 9/11 也不支持在顶点着色器中使用 tex2D 函数。因为在顶点着色器阶段 Shader 无法得到 UV 偏导，而 tex2D 函数需要这样的偏导信息(这和纹理采样时使用的数学运算有关)。如果我们的确需要在顶点着色器中访问纹理，需要使用 tex2Dlod 函数来替代，如：
```
tex2Dlod(tex，float4(uv，0, 0)).
```

而且我们还需要添加 #pragma target 3.0，因为 tex2Dlod 是 Shader Model 3.0 中的特性。


### 5.6.3 Shader 的语义差异

一些语义在某些平台下是等价的，例如 SV_POSITION 和 POSITION。但在另一些平台上，这些语义是不等价的。为了让Shader能够在所有平台上正常工作，我们应该尽可能使用下面的语义来描述 Shader 的输入输出变量。
* 使用 SV_POSITION 来描述顶点着色器输出的顶点位置。
* 使用 SV_Target 来描述片元着色器的输出颜色。


### 5.6.4 其他平台差异

本书只给出了一些最常见的平台差异造成的问题，还有一些差异不再列举。如果读者发现一些 Shader 在平台A下工作良好，而在平台B下出现了问题，可以去 Unity 官方文档(https://docs.unity3d.com/Manual/SL-PlatformDifferences.html)中寻找更多的资料。



## 5.7 Shader 整洁之道

### 5.7.1 float、half、fixed

表5.8 Cg/HLSL 中 3 种精度的数值类型

| 类型 | 精度 |
| --- | --- |
| float | 最高精度，通常32位存储 |
| half  | 中等精度，通常16位存储，精度范围 -60000 ~ +60000 |
| fixed | 最低精度，通常11位存储，精度范围 -2.0 ~ +2.0 |

上面的精度范围并不是绝对正确的，尤其是在不同平台和 GPU 上，它们实际的精度可能和上面给出的范围不一致。通常来讲。
* 大多数现代的桌面GPU 会把所有计算都按最高的浮点精度进行计算，也就是说，float、half、fixed在这些平台上实际是等价的。
* 但在移动平台的GPU上，它们的确会有不同的精度范围，而且不同精度的浮点值的运算速度也会有所差异。因此，我们应该确保在真正的移动平台上验证我们的 Shader 。
* fixed 精度实际上只在一些较旧的移动平台上有用，在大多数现代的GPU上，它们内部把 fixed 和 half 当成同等精度来对待。

一个基本建议是，尽可能使用精度较低的类型，因为这可以优化 Shader 的性能，这一点在移动平台上尤其重要。
从它们大体的值域范围来看，我们可以使用 fixed 类型来存储颜色和单位矢量，如果要存储更大范围的数据可以选择 half 类型，最差情况下再选择使用 float。如果我们的目标平台是移动平台，一定要确保在真实的手机上测试我们的 Shader，这一点非常重要。


### 5.7.2 规范语法
在5.6.2节，我们提到 DirectX 平台对 Shader 的语义有更加严格的要求。这意味着，如果我们要发布到 DirectX 平台上就需要使用更严格的语法。例如，使用和变量类型相匹配的参数数目来对变量进行初始化。

### 5.7.3避免不必要的计算
如果我们毫无节制地在Shader（尤其是片元着色器）中进行了大量计算，那么我们可能很快就会收到 Unity 的错误提示：
 `temporary register limit of 8exceeded`
或
 `Arithmetic instruction limit of 64 exceeded; 65 arithmetic instructions needed to compileprogram`

出现这些错误信息大多是因为我们在Shader 中进行了过多的运算，使得需要的临时寄存器数目或指令数目超过了当前可支持的数目。读者需要知道，不同的 Shader Target、不同的着色器阶段，我们可使用的临时寄存器和指令数目都是不同的。

通常，我们可以通过指定更高等级的Shader Target来消除这些错误。表5.9 给出了 Unity 目前支持的 Shader Target。

| 指令 | 描述 |
| --- | --- |
| #pragma target 2.0 | 默认的 Shader Target 等级。相当于 Direct3D 9 上的 Shader Model 2.0，不支持对顶点纹理的采样，不支持显式的 LOD 纹理采样等 |
| #pragma target 3.0 | 相当于 Direct3D 9 上的 Shader Model 3.0，支持对顶点纹理的采样等 |
| #pragma target 4.0 | 相当于 Direct3D 10 上的 Shader Model 4.0，支持几何着色器等 |
| #pragma target 5.0 | 相当于 Direct3D 11 上的 Shader Model 5.0 |


**什么是 Shader Model ？**

Shader Model 是由微软提出的一套规范，通俗地理解就是它们决定了 Shader 中各个特性（feature）的能力（capability）。这些特性和能力体现在 Shader 能使用的运算指令数目、寄存器个数等各个方面。Shader Model 等级越高，Shader 的能力就越大。

虽然更高等级的 Shader Target 可以让我们使用更多的临时寄存器和运算指令，但一个更好的方法是尽可能减少 Shader 中的运算，或者通过预计算的方式来提供更多的数据。


### 5.7.4 慎用分支和循环语句

如果我们在Shader中使用了大量的流程控制语句，那么这个 Shader的性能可能会成倍下降。一个解决方法是，我们应该尽量把计算向流水线上端移动，例如把放在片元着色器中的计算放到顶点着色器中，或者直接在CPU中进行预计算，再把结果传递给Shader。

当然，有时我们不可避免地要使用分支语句来进行运算，那么一些建议是:
* 分支判断语句中使用的条件变量最好是常数，即在 Shader运行过程中不会发生变化;
* 每个分支中包含的操作指令数尽可能少;
* 分支的嵌套层数尽可能少。


### 5.7.5 不要除以 0 
除以 0 会导致 Shader 结果不可预测，有些会得到白色，有些会得到黑色，有些平台上 Shader 可能会直接崩溃。

一个解决方法是，对那些除数可能为0的情况，强制截取到非0范围。在一些资料中，读者可能也会看到使用 if 语句来判断除数是否为0的例子。另一个方法是，使用一个很小的浮点值来代替 0，例如 0.000001。


## 5.8 扩展阅读

读者可以在《GPU精粹2》中的GPU流程控制一章^[1]^中更加深入地了解为什么流程控制语句在GPU上会影响性能。在5.7.3节我们提到了Shader中临时寄存器数目和运算指令都有限制，实际上Shader Model对顶点着色器和片元着色器中使用的指令数、临时寄存器、常量寄存器、输入/输出寄存器、纹理等数目都进行了规定。读者可以在Wiki的相关资料^[2]^和HLSL 的手册^[3]^中找到更多的内容。

[1] Mark Harris, Ian Buck. "GPU Flow-Control Idioms." In GPU Gems 2.中译本: GPU精粹 2: 高性能图形芯片和通用计算编程技巧，法尔译，清华大学出版社，2007年。
[2] High-Level Shading Language，Wiki(https://en.wikipedia.org/wiki/High-Level_Shading_Language)。
[3] Shader Models vs Shader Profiles，HLSL手册(https://msdn.microsoft.com/en-us/librarylwindows/desktop/bb509626(v=vs.85).aspx)。



----------------------------------------------------------------------



# 第6章 Unity 中的基础光照

## 6.1 我们是如何看到这个世界的

通常来讲，我们要模拟真实的光照环境来生成一张图像，需要考虑3种物理现象。
* 首先，光线从**光源（light source）** 中被发射出来。
* 然后，光线和场景中的一些物体相交：一些光线被物体吸收了，而另一些光线被散射到其他方向。
* 最后，摄像机吸收了一些光，产生了一张图像。

### 6.1.1 光源

在实时渲染中，我们通常把光源当成一个没有体积的点，用 $l$ 来表示它的方向。在光学里我们使用**辐照度（irradiance）** 来描述光源的能量分布。我们可以使用光源方向 $l$ 和表面法线 $n$ 之间的夹角的余弦值来得到辐照度。

![图6.1 在左图中，光是垂直照射到物体表面，因此光线之间的垂直距离保持不变；而在右图中，光是斜着照射到物体表面，在物体表面光线之间的距离是d/cosθ，因此单位面积上接收到的光线数目要少于左图](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.1.jpg)

因为辐照度是和照射到物体表面时光线之间的距离 $d/ \cos \theta$ 成反比的, 因此辐照度就和 $\cos \theta$ 成正比。 $\cos \theta$ 可以使用光源方向 $l$ 和表面法线 $n$ 的点积来得到。这就是使用点积来计算辐照度的由来。


### 6.1.2 吸收和散射

光线由光源发射出来后，就会与一些物体相交。通常，相交的结果有两个：**散射（scattering）** 和 **吸收（absorption）**。

散射只改变光线的方向，但不改变光线的密度和颜色。而吸收只改变光线的密度和颜色，但不改变光线的方向。

光线在物体表面经过散射后，有两种方向：
* 一种将会散射到物体内部，这种现象被称为**折射（refraction）** 或 **透射（transmission）**；
* 另一种将会散射到外部，这种现象被称为**反射（reflection）**。

对于不透明物体，折射进入物体内部的光线还会继续与内部的颗粒进行相交，其中一些光线最后会重新发射出物体表面，而另一些则被物体吸收。那些从物体表面重新发射出的光线将具有和入射光线不同的方向分布和颜色。图6.2 给出了这样的一个例子。

![图6.2 散射时，光线会发生折射和反射现象。对于不透明物体，折射的光线会在物体内部继续传播，最终有一部分光线会重新从物体表面被发射出去](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.2.jpg)

为了区分这两种不同的散射方向，我们在光照模型中使用了不同的部分来计算它们：
* **高光反射（specular）** 部分表示物体表面是如何反射光线的；
* **漫反射（diffuse）** 部分则表示有多少光线会被折射、吸收和散射出表面。

根据入射光线的数量和方向，我们可以计算出射光线的数量和方向，我们通常使用**出射度(exitance)** 来描述它。辐照度和出射度之间是满足线性关系的，而它们之间的比值就是材质的漫反射和高光反射属性。

在本章中，我们假设漫反射部分是没有方向性的，也就是说，光线在所有方向上是平均分布的。同时,我们也只考虑某一个特定方向上的高光反射。


### 6.1.3 着色

**着色（shading）** 指的是，根据材质属性（如漫反射属性等）、光源信息（如光源方向、辐照度等），使用一个等式去计算沿某个观察方向的出射度的过程。我们也把这个等式称为**光照模型（Lighting Model）**。


### 6.1.4 BRDF 光照模型

当给定模型表面上的一个点时，BRDF包含了对该点外观的完整的描述。在图形学中，**BRDF（Bidirectional Reflectance Distribution Function）** 大多使用一个数学公式来表示，并且提供了一些参数来调整材质属性。通俗来讲，当给定入射光线的方向和辐照度后，BRDF 可以给出在某个出射方向上的光照能量分布。

本章涉及的 BRDF 都是对真实场景进行理想化和简化后的模型，也就是说，它们并不能真实地反映物体和光线之间的交互，这些光照模型被称为是经验模型。

计算机图形学的第一定律：如果它看起来是对的，那么它就是对的。



## 6.2 标准光照模型

虽然光照模型有很多种类，但在早期的游戏引擎中往往只使用一个光照模型，这个模型被称为标准光照模型。实际上，在BRDF理论被提出之前，标准光照模型就已经被广泛使用了。

> 在1975年，著名学者裴祥风（Bui Tuong Phong）提出了标准光照模型背后的基本理念。标准光照模型只关心直接光照（direct light），也就是那些直接从光源发射出来照射到物体表面后，经过物体表面的一次反射直接进入摄像机的光线。

它把进入到摄像机内的光线分为4个部分，每个部分使用一种方法来计算它的贡献度：

* **自发光（emissive）**，本书使用 $c_{emissive}$ 来表示。这个部分用于描述当给定一个方向时，一个表面本身会向该方向发射多少辐射量。需要注意的是，如果没有使用全局光照（global illumination）技术，这些自发光的表面并不会真的照亮周围的物体，而是它本身看起来更亮了而已。

* **高光反射（specular）** ，本书使用 $c_{specular}$ 来表示。这个部分用于描述当光线从光源照射到模型表面时，该表面会在完全镜面反射方向散射多少辐射量。

* **漫反射（diffuse）**，本书使用 $c_{diffuse}$ 来表示。这个部分用于描述，当光线从光源照射到模型表面时，该表面会向每个方向散射多少辐射量。

* **环境光（ambient）**，本书使用 $c_{ambient}$ 来表示。它用于描述其他所有的间接光照。
通常是一个全局变量，即场景中的所有物体都使用这个环境光。

### 6.2.3 漫反射

因为反射完全随机，可以认为在任何反射方向上的分布都是一样的，因此入射光线的角度很重要。

漫反射光照符合 **兰伯特定律（Lambert's law）** ：反射光线的强度与表面法线和光源方向之间夹角的余弦值成正比。

$$
c_{diffuse} = (c_{light} \cdot m_{diffuse}) max(0, \hat{n} \cdot \hat{l})
$$

其中，$c_{light}$ 是光源颜色，$m_{diffuse}$ 是材质的漫反射颜色，$\hat{n}$ 是表面法线，$\hat{l}$ 是指向光源的单位矢量。max函数防止物体被从后面来的光源照亮。max 防止点乘结果为负值，这可以防止物体被从后面来的光源照亮。


### 6.2.4 高光反射

计算高光反射需要知道表面法线 $\hat n$ 、视角方向 $\hat v$ 、光源方向 $\hat l$ 、反射方向 $\hat r$ 。

反射方向可以由表面法线和光源方向计算：$ \hat r = 2(\hat n \cdot \hat l) \hat n - \hat l$ 。

利用Phong模型来计算高光反射：

$$
c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat{v} \cdot \hat{r})^{m_{gloss}}
$$

其中，$c_{light}$ 是光源颜色，$m_{specular}$ 是材质的高光反射颜色，$m_{gloss}$ 是材质的**光泽度（gloss）**，也被称为**反光度（shininess）**。它用于控制高光区域的“亮点”有多宽， $m_{gloss}$ 越大，亮点就越小。

Blinn模型引入了一个新的矢量 $\hat h$ ，它是通过对 $\hat v$ 和 $\hat l$ 取平均后再归一化得到的： $\hat h = \frac {\hat v + \hat l} {|\hat v + \hat l|}$ 。

Blinn 模型的公式如下：

$$
c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat n \cdot \hat h)^{m_{gloss}}
$$

在硬件实现时，如果摄像机和光源距离模型足够远的话，Blinn 模型会快于 Phong 模型，这是因为，此时可以认为 $\hat v$ 和 $\hat l$ 都是定值，因此 $\hat h$ 将是一个常量。但是，当 $\hat v$ 或者 $\hat l$ 不是定值时，Phong 模型可能反而更快一些。


### 6.2.5 逐像素还是逐顶点

**逐像素光照（per-pixel lighting）** ：在片元着色器中计算。在逐像素光照中，我们会以每个像素为基础，得到它的法线（可以是对顶点法线插值得到的，也可以是从法线纹理中采样得到的），然后进行光照模型的计算。这种在面片之间对顶点法线进行插值的技术被称为 **Phong 着色（Phong shading）** ，也被称为 Phong 插值或法线插值着色技术。这不同于我们之前讲到的 Phong 光照模型。

**逐顶点光照（per-vertex lighting）** ：在顶点着色器中计算。也被称为 **高洛德着色（Gouraud shading）。在逐顶点光照中，我们在每个顶点上计算光照，然后会在渲染图元内部进行线性插值，最后输出成像素颜色。由于点数目往往远小于像素数目，因此逐顶点光照的计算量往往要小于逐像素光照。
但是，由于逐顶点光照依赖于线性插值来得到像素光照，因此，当光照模型中有非线性的计算（例如计算高光反射时）时，逐顶点光照就会出问题。在后面的章节中，我们将会看到这种情况。而且，由于逐顶点光照会在渲染图元内部对顶点颜色进行插值，这会导致渲染图元内部的颜色总是暗于顶点处的最高颜色值，这在某些情况下会产生明显的棱角现象。


### 6.2.6 总结

虽然标准光照模型仅仅是一个经验模型，也就是说，它并不完全符合真实世界中的光照现象。但由于它的易用性、计算速度和得到的效果都比较好，因此仍然被广泛使用。

标准光照模型有很多不同的叫法。例如，一些资料中称它为Phong光照模型，因为裴祥风（Bui Tuong Phong）首先提出了使用漫反射和高光反射的和来对反射光照进行建模的基本思想，并且提出了基于经验的计算高光反射的方法（用于计算漫反射光照的兰伯特模型在那时已经被提出了）。而后，由于Blinn的方法简化了计算而且在某些情况下计算更快，我们把这种模型称为 **Blinn-Phong 光照模型** 。

局限: 首先，有很多重要的物理现象无法用Blinn-Phong模型表现出来，例如 **菲涅耳反射（Fresnel reflection）**。其次，Blinn-Phong 模型是 **各项同性（isotropic）** 的，也就是说，当我们固定视角和光源方向旋转这个表面时，反射不会发生任何改变。但有些表面是具有 **各向异性（anisotropic）** 反射性质的，例如拉丝金属、毛发等。


## 6.3 Unity 中的环境光和自发光

Unity 中的环境光可以在 Window - Rendering - Lighting - Environment 中设置。在 Shader 中，我们只需要通过 Unity 的内置变量 UNITY_LIGHTMODEL_AMBIENT 就可以得到环境光的颜色和强度信息。

计算自发光只需要在片元着色器输出最后的颜色之前，把材质的自发光颜色添加到输出颜色上


## 6.4 在 Unity Shader 中实现漫反射光照模型

漫反射计算公式： $c_{diffuse} = (c_{light} \cdot m_{diffuse}) max(0, \hat{n} \cdot \hat{l})$

为了防止点积结果为负值，我们需要使用 max 操作，而 CG 提供了这样的函数。在本例中，使用 CG 的另一个函数可以达到同样的目的，即 saturate 函数。

> 函数：saturate(x)
> 参数：x：为用于操作的标量或矢量，可以是float、float2、float3等类型。
> 描述：把x截取在[0,1]范围内，如果x是一个矢量，那么会对它的每一个分量进行这样的操作。


### 6.4.1 实践: 逐顶点光照

![图6.6 逐顶点的漫反射光照效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.6.jpg)


准备工作：
1. 在 Unity 中新建一个场景 Scene_6_4，去掉天空盒；
2. 新建 Shader 命名为 Chapter6-DiffuseVertexLevel；
3. 在 Shader 上右键，新建材质；
4. 在场景中新建一个胶囊体，将材质赋给该胶囊体；
5. 保存场景。

Shader 实现：

```
// 1. 为 Shader 起名
Shader "Unity Shaders Book/Chapter 6/Diffuse Vertex-Level"
{
    Properties
    {
        // 2. 控制材质的漫反射颜色
        _Diffuse ("Diffuse", Color) = (1,1,1,1)
    }
    SubShader
    {
        // 3. 在 SubShader 中定义 Pass 语义块。因为顶点/片元着色器的代码需要写在 Pass 语义块中。
        // 在 Pass 的第一行指明该 Pass 的光照模式
        Pass
        {
            Tags {"LightMode"="ForwardBase"}

            CGPROGRAM

            // 4. 告诉 Unity 顶点着色器和片元着色器的函数名
            #pragma vertex vert
            #pragma fragment frag
            
            // 5. 为了使用 Unity 内置变量，如 _LightColor0，需要包含 Lighting.cginc 文件
            #include "Lighting.cginc"

            // 6. 为了在 Shader 中使用 Properties 语义块中声明的属性
            // 我们需要定义一个和该属性类型相匹配的变量
            fixed4 _Diffuse;
            
            // 7. 定义顶点着色器的输入和输出结构体（输出结构体也是片元着色器的输入结构体）
            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                fixed3 color : COLOR;
            };

            // 8. 实现逐顶点的漫反射光照
            v2f vert (a2v v)
            {
                v2f o;
                // 把顶点位置从模型空间转换到裁剪空间
                o.pos = UnityObjectToClipPos(v.vertex);
                
                // 通过Unity内置变量 UNITY_LIGHTMODEL_AMBIENT 得到环境光部分
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                // 将法线转换到世界空间（新版Unity中 '_World2Object' 会被替换为 'unity_WorldToObject'）
                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));
                // 获取世界空间光源方向
                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);
                // 计算漫反射光照
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));
                
                // 计算最终颜色
                o.color = ambient + diffuse;

                return o;
            }

            // 9. 由于所有计算都在顶点着色器中完成了，所以片元着色器中只需要把顶点颜色输出即可
            fixed4 frag (v2f i) : SV_Target
            {
                return fixed4(i.color, 1.0);
            }
            ENDCG
        }
    }

    // 10. 最后，我们需要把回调 Shader 设置为 Diffuse
    FallBack "Diffuse"
}
```


### 6.4.2 实践: 逐像素光照

逐像素光照可以得到更平滑的效果：

![图6.7 逐像素的漫反射光照效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.7.jpg)

准备工作：
1. 使用上一节中新建的场景
2. 新建 Shader 命名为 Chapter6-DiffusePixelLevel；
3. 在 Shader 上右键，新建材质；
4. 在场景中新建一个胶囊体，将材质赋给该胶囊体；

逐像素和逐顶点 Shader 实现非常相似，因此我们首先把 6.4.1 中的代码复制过来，然后进行修改。

Shader 实现：

```
Shader "Unity Shaders Book/Chapter 6/Diffuse Pixel-Level"
{
    // ......
            // 1. 修改顶点着色器的输入结构体
            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
            };

            // 2. 顶点着色器不需要计算光照模型，只需要把世界空间下的法线传递给片元着色器即可
            v2f vert (a2v v)
            {
                v2f o;
                // 把顶点位置从模型空间转换到裁剪空间
                o.pos = UnityObjectToClipPos(v.vertex);
                
                // 将法线转换到世界空间（新版Unity中 '_World2Object' 会被替换为 'unity_WorldToObject'）
                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);

                return o;
            }

            // 3. 片元着色器需要计算漫反射光照模型
            fixed4 frag (v2f i) : SV_Target
            {
                // 通过Unity内置变量 UNITY_LIGHTMODEL_AMBIENT 得到环境光部分
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                // 世界空间法线
                fixed3 worldNormal = normalize(i.worldNormal);
                // 获取世界空间光源方向
                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);
                // 计算漫反射光照
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLight));
                
                fixed3 color = ambient + diffuse;

                return fixed4(color, 1.0);
            }
    // ......
}
```


### 6.4.3 半兰伯特模型

在 6.4.1 小节中，我们使用的漫反射光照模型也被称为 **兰伯特光照模型** ，因为它符合兰伯特定律——在平面某点漫反射光的光强与该反射点的法向量和入射光角度的余弦值成正比。

然而，兰伯特光照模型存在一些问题：在光照无法到达的区域，模型的外观通常是全黑的，没有任何明暗变化。为了解决这个问题，Valve公司在开发游戏《半条命》时提出了一种技术，由于该技术是在原兰伯特光照模型的基础上进行了一个简单的修改，因此被称为 **半兰伯特（Half Lambert）光照模型** 。

广义的半兰伯特光照模型的公式： 

$$
c_{diffuse} = (c_{light} \cdot m_{diffuse}) (\alpha (\hat{n} \cdot \hat{l}) + \beta)
$$

可以看出，与原兰伯特模型相比，半兰伯特光照模型没有使用 max 操作来防止 $\hat{n} 和 \hat{l}$ 的点积为负值， 而是对其结果进行了一个 α 倍的缩放再加上一个 β 大小的偏移。绝大多数情况下，α 和 β 的均值为 0.5，即公式为：

$$
c_{diffuse} = (c_{light} \cdot m_{diffuse}) (0.5 (\hat{n} \cdot \hat{l}) + 0.5)
$$

通过这样的方式，我们可以把 $\hat{n} \cdot \hat{l}$ 的结果范围 从 [-1, 1] 映射到 [0, 1] 范围内。

对 6.4.2 小节中的逐像素光照模型进行修改，我们可以得到半兰伯特光照模型的实现：

新建 Shader 命名为 Chapter6-HalfLambert ，将 6.4.2 中的代码复制过来，然后进行修改：

```
Shader "Unity Shaders Book/Chapter 6/Half Lambert"
{
    // ......
            fixed4 frag (v2f i) : SV_Target
            {
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 worldNormal = normalize(i.worldNormal);
                
                fixed3 worldLight = normalize(_WorldSpaceLightPos0.xyz);
                // 半兰伯特光照模型
                fixed halfLambert = dot(worldNormal, worldLight) * 0.5 + 0.5;
                
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * halfLambert;
                
                fixed3 color = ambient + diffuse;

                return fixed4(color, 1.0);
            }
    // ......
}
```


逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果：

![图6.8 逐顶点漫反射光照、逐像素漫反射光照、半兰伯特光照的对比效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.8.jpg)



## 6.5 在 Unity Shader 中实现高光反射光照模型

基本光照模型中高光反射部分计算公式：

$$
c_{specular} = (c_{light} \cdot m_{specular}) max(0, \hat{v} \cdot \hat{r})^{m_{gloss}}
$$

反射方向 $\hat{r}$ 由法线 $\hat{n}$ 和光源方向 $\hat{l}$ 计算得出： $\hat{r} = \hat{l} - 2(\hat{n} \cdot \hat{l}) \hat{n}$

上述公式很简单，但 CG 提供了计算反射方向的函数 reflect 。

> 函数：reflect(i, n)
> 参数：i：光线入射方向；n：法线方向。可以是float、float2、float3等类型。
> 描述：当给定入射方向 i 和法线方向 n 时，返回反射方向。


### 6.5.1 实践: 逐顶点光照

逐顶点的高光反射光照效果：

![图6.10 逐顶点的高光反射光照效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.10.jpg)

准备工作：
1. 新建场景 Scene_6_5，去掉天空盒；
2. 新建 Shader 命名为 Chapter6-SpecularVertexLevel；
3. 在 Shader 上右键，新建材质；
4. 在场景中新建一个胶囊体，将材质赋给该胶囊体；
5. 保存场景。

Shader 实现：

```
Shader "Unity Shaders Book/Chapter 6/Specular Vertex-Level"
{
    Properties
    {
        _Diffuse ("Diffuse", Color) = (1,1,1,1)
        _Specular ("Specular", Color) = (1,1,1,1)
        _Gloss ("Gloss", Range(0, 128)) = 40
    }
    SubShader
    {
        Pass
        {
            Tags {"LightMode"="ForwardBase"}

            CGPROGRAM

            #pragma vertex vert
            #pragma fragment frag

            #include "Lighting.cginc"

            fixed4 _Diffuse;
            fixed4 _Specular;
            float _Gloss;

            struct a2v
            {
                float4 vertex : POSITION;
                float3 normal : NORMAL;
            };

            struct v2f
            {
                float4 pos : SV_POSITION;
                fixed3 color : COLOR;
            };

            v2f vert (a2v v)
            {
                v2f o;
                
                o.pos = UnityObjectToClipPos(v.vertex);
                
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 worldNormal = normalize(mul(v.normal, (float3x3)unity_WorldToObject));
                
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));
                
                // 反射方向
                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));
                // 观察方向
                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - mul(_Object2World, v.vertex).xyz);
                // 计算高光反射光照
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);

                // 计算最终颜色
                o.color = ambient + diffuse + specular;

                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                return fixed4(i.color, 1.0);
            }

            ENDCG
        }
    }
    // 回调设置为内置的 Specular
    FallBack "Specular"
}
```


### 6.5.2 实践: 逐像素光照

逐像素的高光反射光照效果：

![图6.11 逐像素的高光反射光照效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.11.jpg)

新建 Shader 命名为 Chapter6-SpecularPixelLevel，将 6.5.1 中的代码复制过来，然后进行修改：

```
Shader "Unity Shaders Book/Chapter 6/Specular Pixel-Level"
{
    // ......
            // 1. 修改顶点着色器的输出结构体
            struct v2f
            {
                float4 pos : SV_POSITION;
                float3 worldNormal : TEXCOORD0;
                float3 worldPos : TEXCOORD1;
            };

            // 2. 顶点着色器计算世界空间法线、世界空间位置
            v2f vert (a2v v)
            {
                v2f o;
                
                o.pos = UnityObjectToClipPos(v.vertex);
                
                o.worldNormal = mul(v.normal, (float3x3)unity_WorldToObject);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;

                return o;
            }

            // 3. 片元着色器计算关键的光照模型
            fixed4 frag (v2f i) : SV_Target
            {
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 worldNormal = normalize(i.worldNormal);
                
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));
                
                // 反射方向
                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));
                // 观察方向
                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);
                // 计算高光反射光照
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(saturate(dot(reflectDir, viewDir)), _Gloss);

                // 计算最终颜色
                fixed3 color = ambient + diffuse + specular;

                return fixed4(color, 1.0);
            }

    // ......
}
```


### 6.5.3 Blinn-Phong 光照模型

在 6.5.2 小节中，我们给出了 Phong 光照模型在 Unity 中的实现，我们之前还提到另一种高光反射的实现方法—— Blinn-Phong 光照模型。Blinn 模型没有使用反射方向，而是引入了一个新的矢量 $\hat{h}$ ，它是通过对 $\hat v$ 和 $\hat l$ 取平均后再归一化得到的： $\hat h = \frac {\hat v + \hat l} {|\hat v + \hat l|}$ 。

Blinn-Phong 光照模型的公式：

$$
c_{specular} = (c_{light} \cdot m_{specular}) max(0, (\hat n \cdot \hat h))^{m_{gloss}}
$$

新建 Shader 命名为 Chapter6-BlinnPhong ，将 6.5.2 中的代码复制过来，然后进行修改：

```
Shader "Unity Shaders Book/Chapter 6/Blinn-Phong"
{
    // ......
    
            fixed4 frag (v2f i) : SV_Target
            {
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 worldNormal = normalize(i.worldNormal);
                
                fixed3 worldLightDir = normalize(_WorldSpaceLightPos0.xyz);
                
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));
                

                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));

                fixed3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos.xyz);
                // 计算半角向量
                fixed3 halfDir = normalize(worldLightDir + viewDir);
                // 计算高光反射光照
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);


                fixed3 color = ambient + diffuse + specular;

                return fixed4(color, 1.0);
            }
    // ......
}
```

逐顶点高光反射光照、逐像素高光反射光照、Blinn-Phong 光照模型的对比效果：

![图6.12 逐顶点高光反射光照、逐像素高光反射光照、Blinn-Phong 光照模型的对比效果](https://raw.githubusercontent.com/Ineloquent0/notes/main/Shader/Unity%20Shader%20%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81/images/6.12.jpg)



## 6.6 使用 Unity 内置的函数

表6.1 UnityCG.cginc 中一些常用的帮助函数

 函数名  | 描述 
------------- | -------------
float3 WorldSpaceViewDir (float4 v) | 输入一个模型空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向。内部实现使用了 UnityWorldSpaceViewDir 函数
float3 UnityWorldSpaceViewDir (float4 v) | 输入一个世界空间中的顶点位置，返回世界空间中从该点到摄像机的观察方向
float3 ObjSpaceViewDir (float4 v) | 输入一个模型空间中的顶点位置,返回模型空间中从该点到摄像机的观察方向
float3 WorldSpaceLightDir (float4 v) | 仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回世界空间中从该点到光源的光照方向。内部实现使用了UnityWorldSpaceLightDir函数。没有被归一化
float3 UnityWorldSpaceLightDir (float4 v) | 仅可用于前向渲染中。输入一个世界空间中的顶点位置，返回世界空间中从该点到光源的光照方向。没有被归一化
float3 ObiSpaceLightDir (float4 v) | 仅可用于前向渲染中。输入一个模型空间中的顶点位置，返回模型空间中从该点到光源的光照方向。没有被归一化
float3 UnityObjectToWorldNormal (float3 norm) | 把法线方向从模型空间转换到世界空间中
float3 UnityObjectToWorldDir (float3 dir) | 把方向矢量从模型空间变换到世界空间中
float3 UnityWorldToObjectDir (float3 dir) | 把方向矢量从世界空间变换到模型空间中

需要注意的是，这些函数都没有保证得到的方向矢量是单位矢量，因此，我们需要在使用前把它们归一化。

计算光源方向的3个函数：WorldSpaceLightDir、UnityWorldSpaceLightDir 和 ObjSpaceLightDir 中，Unity 帮我们处理了不同种类光源的情况。需要注意的是，这3个函数仅可用于前向渲染。这是因为只有在前向渲染时，这3个函数里使用的内置变量 WorldSpaceLightPos0等才会被正确赋值。


下面使用 Unity 内置函数改写之前的 Shader：

新建 Shader 命名为 Chapter6-BlinnPhongUseBuildInFunction ，Chapter6-BlinnPhong 中的代码复制过来，然后进行修改：

```
Shader "Unity Shaders Book/Chapter 6/Blinn-Phong Use Build-In Function"
{
    // ......
            v2f vert (a2v v)
            {
                v2f o;
                
                o.pos = UnityObjectToClipPos(v.vertex);
                
                // 使用内置函数来计算世界空间下的法线方向
                o.worldNormal = UnityObjectToWorldNormal(v.normal);
                o.worldPos = mul(unity_ObjectToWorld, v.vertex).xyz;

                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                fixed3 ambient = UNITY_LIGHTMODEL_AMBIENT.xyz;

                fixed3 worldNormal = normalize(i.worldNormal);
                
                // 使用内置函数来计算世界空间下的光照方向
                fixed3 worldLightDir = normalize(UnityWorldSpaceLightDir(i.worldPos));
                
                fixed3 diffuse = _LightColor0.rgb * _Diffuse.rgb * saturate(dot(worldNormal, worldLightDir));
                
                fixed3 reflectDir = normalize(reflect(-worldLightDir, worldNormal));
                // 使用内置函数来计算视角方向
                fixed3 viewDir = normalize(UnityWorldSpaceViewDir(i.worldPos));

                fixed3 halfDir = normalize(worldLightDir + viewDir);
                
                fixed3 specular = _LightColor0.rgb * _Specular.rgb * pow(max(0, dot(worldNormal, halfDir)), _Gloss);

                fixed3 color = ambient + diffuse + specular;

                return fixed4(color, 1.0);
            }
    // ......
}
```



